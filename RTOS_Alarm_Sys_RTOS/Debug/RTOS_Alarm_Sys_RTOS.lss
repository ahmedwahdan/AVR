
RTOS_Alarm_Sys_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d90  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000082  00800060  00001d90  00001e24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000046e  008000e2  008000e2  00001ea6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ea6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001ed8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e0  00000000  00000000  00001f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000052ca  00000000  00000000  000022f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000160c  00000000  00000000  000075be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002cbc  00000000  00000000  00008bca  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b18  00000000  00000000  0000b888  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000017d2  00000000  00000000  0000c3a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000045b0  00000000  00000000  0000db72  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000428  00000000  00000000  00012122  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 12 07 	jmp	0xe24	; 0xe24 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e9       	ldi	r30, 0x90	; 144
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3e       	cpi	r26, 0xE2	; 226
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a2 ee       	ldi	r26, 0xE2	; 226
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 35       	cpi	r26, 0x50	; 80
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 91 04 	call	0x922	; 0x922 <main>
      8a:	0c 94 c6 0e 	jmp	0x1d8c	; 0x1d8c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	e7 ee       	ldi	r30, 0xE7	; 231
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	8c ee       	ldi	r24, 0xEC	; 236
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	e3 ee       	ldi	r30, 0xE3	; 227
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	87 ee       	ldi	r24, 0xE7	; 231
      be:	93 e0       	ldi	r25, 0x03	; 3
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	ab ee       	ldi	r26, 0xEB	; 235
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	c6 3e       	cpi	r28, 0xE6	; 230
      f2:	d3 40       	sbci	r29, 0x03	; 3
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 e7 00 	lds	r30, 0x00E7	; 0x8000e7 <xStart>
      fc:	f0 91 e8 00 	lds	r31, 0x00E8	; 0x8000e8 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	a7 ee       	ldi	r26, 0xE7	; 231
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	e3 3e       	cpi	r30, 0xE3	; 227
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	87 ee       	ldi	r24, 0xE7	; 231
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	a7 ee       	ldi	r26, 0xE7	; 231
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <Keypad_Init>:
 #include "LCD_Lib.h"
 extern const Keypad_config_t g_Keypad_Col_Config[Col_numbers];
 extern const Keypad_config_t g_Keypad_Row_Config[Row_numbers];
 extern const uint8_t g_Keypad_Map[Row_numbers][Col_numbers];
 void Keypad_Init(void)
 {
     22c:	cf 92       	push	r12
     22e:	df 92       	push	r13
     230:	ef 92       	push	r14
     232:	ff 92       	push	r15
     234:	0f 93       	push	r16
     236:	1f 93       	push	r17
     238:	cf 93       	push	r28
     23a:	df 93       	push	r29
     23c:	00 d0       	rcall	.+0      	; 0x23e <Keypad_Init+0x12>
     23e:	00 d0       	rcall	.+0      	; 0x240 <Keypad_Init+0x14>
     240:	cd b7       	in	r28, 0x3d	; 61
     242:	de b7       	in	r29, 0x3e	; 62
     244:	04 e8       	ldi	r16, 0x84	; 132
     246:	10 e0       	ldi	r17, 0x00	; 0
     248:	0f 2e       	mov	r0, r31
     24a:	fc e8       	ldi	r31, 0x8C	; 140
     24c:	cf 2e       	mov	r12, r31
     24e:	f0 e0       	ldi	r31, 0x00	; 0
     250:	df 2e       	mov	r13, r31
     252:	f0 2d       	mov	r31, r0
	GPIO_Init_Param_t keypadParam;
	
for (index=0;index<Col_numbers;index++)
	{
		/* Columns are output */
		keypadParam.Direction = (1U<<g_Keypad_Col_Config[index].PIN_Number);
     254:	ee 24       	eor	r14, r14
     256:	e3 94       	inc	r14
     258:	f1 2c       	mov	r15, r1
     25a:	c7 01       	movw	r24, r14
     25c:	f8 01       	movw	r30, r16
     25e:	00 80       	ld	r0, Z
     260:	02 c0       	rjmp	.+4      	; 0x266 <Keypad_Init+0x3a>
     262:	88 0f       	add	r24, r24
     264:	99 1f       	adc	r25, r25
     266:	0a 94       	dec	r0
     268:	e2 f7       	brpl	.-8      	; 0x262 <Keypad_Init+0x36>
     26a:	8b 83       	std	Y+3, r24	; 0x03
		/* Columns are output, they initialized high */
		keypadParam.IsPulledUp= (1U<<g_Keypad_Col_Config[index].PIN_Number);
     26c:	8c 83       	std	Y+4, r24	; 0x04
     26e:	31 97       	sbiw	r30, 0x01	; 1
		keypadParam.Port_Name = g_Keypad_Col_Config[index].PORT_Name;
     270:	90 81       	ld	r25, Z
     272:	99 83       	std	Y+1, r25	; 0x01
		keypadParam.Mask = (1U<<g_Keypad_Col_Config[index].PIN_Number);
     274:	8a 83       	std	Y+2, r24	; 0x02
		GPIO_Init(&keypadParam);
     276:	ce 01       	movw	r24, r28
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	0e 94 cf 04 	call	0x99e	; 0x99e <GPIO_Init>
     27e:	0e 5f       	subi	r16, 0xFE	; 254
     280:	1f 4f       	sbci	r17, 0xFF	; 255
 void Keypad_Init(void)
 {
	uint8_t index;
	GPIO_Init_Param_t keypadParam;
	
for (index=0;index<Col_numbers;index++)
     282:	0c 15       	cp	r16, r12
     284:	1d 05       	cpc	r17, r13
     286:	49 f7       	brne	.-46     	; 0x25a <Keypad_Init+0x2e>
     288:	0c e7       	ldi	r16, 0x7C	; 124
     28a:	10 e0       	ldi	r17, 0x00	; 0
     28c:	0f 2e       	mov	r0, r31
     28e:	f4 e8       	ldi	r31, 0x84	; 132
     290:	cf 2e       	mov	r12, r31
     292:	f0 e0       	ldi	r31, 0x00	; 0
     294:	df 2e       	mov	r13, r31
     296:	f0 2d       	mov	r31, r0
	for (index=0;index<Row_numbers;index++)
	{
		/* Rows are input */
		keypadParam.Direction = 0U;
		/* Rows are input, they are internally pulled up */
		keypadParam.IsPulledUp=(1U<<g_Keypad_Row_Config[index].PIN_Number);;
     298:	ee 24       	eor	r14, r14
     29a:	e3 94       	inc	r14
     29c:	f1 2c       	mov	r15, r1
	}

	for (index=0;index<Row_numbers;index++)
	{
		/* Rows are input */
		keypadParam.Direction = 0U;
     29e:	1b 82       	std	Y+3, r1	; 0x03
		/* Rows are input, they are internally pulled up */
		keypadParam.IsPulledUp=(1U<<g_Keypad_Row_Config[index].PIN_Number);;
     2a0:	c7 01       	movw	r24, r14
     2a2:	f8 01       	movw	r30, r16
     2a4:	00 80       	ld	r0, Z
     2a6:	02 c0       	rjmp	.+4      	; 0x2ac <Keypad_Init+0x80>
     2a8:	88 0f       	add	r24, r24
     2aa:	99 1f       	adc	r25, r25
     2ac:	0a 94       	dec	r0
     2ae:	e2 f7       	brpl	.-8      	; 0x2a8 <Keypad_Init+0x7c>
     2b0:	8c 83       	std	Y+4, r24	; 0x04
     2b2:	31 97       	sbiw	r30, 0x01	; 1
		keypadParam.Port_Name = g_Keypad_Row_Config[index].PORT_Name;
     2b4:	90 81       	ld	r25, Z
     2b6:	99 83       	std	Y+1, r25	; 0x01
		keypadParam.Mask = (1U<<g_Keypad_Row_Config[index].PIN_Number);
     2b8:	8a 83       	std	Y+2, r24	; 0x02
		GPIO_Init(&keypadParam);
     2ba:	ce 01       	movw	r24, r28
     2bc:	01 96       	adiw	r24, 0x01	; 1
     2be:	0e 94 cf 04 	call	0x99e	; 0x99e <GPIO_Init>
     2c2:	0e 5f       	subi	r16, 0xFE	; 254
     2c4:	1f 4f       	sbci	r17, 0xFF	; 255
		keypadParam.Port_Name = g_Keypad_Col_Config[index].PORT_Name;
		keypadParam.Mask = (1U<<g_Keypad_Col_Config[index].PIN_Number);
		GPIO_Init(&keypadParam);
	}

	for (index=0;index<Row_numbers;index++)
     2c6:	0c 15       	cp	r16, r12
     2c8:	1d 05       	cpc	r17, r13
     2ca:	49 f7       	brne	.-46     	; 0x29e <Keypad_Init+0x72>
		keypadParam.IsPulledUp=(1U<<g_Keypad_Row_Config[index].PIN_Number);;
		keypadParam.Port_Name = g_Keypad_Row_Config[index].PORT_Name;
		keypadParam.Mask = (1U<<g_Keypad_Row_Config[index].PIN_Number);
		GPIO_Init(&keypadParam);
	}
 }
     2cc:	0f 90       	pop	r0
     2ce:	0f 90       	pop	r0
     2d0:	0f 90       	pop	r0
     2d2:	0f 90       	pop	r0
     2d4:	df 91       	pop	r29
     2d6:	cf 91       	pop	r28
     2d8:	1f 91       	pop	r17
     2da:	0f 91       	pop	r16
     2dc:	ff 90       	pop	r15
     2de:	ef 90       	pop	r14
     2e0:	df 90       	pop	r13
     2e2:	cf 90       	pop	r12
     2e4:	08 95       	ret

000002e6 <Keypad_getkey>:
 uint8_t Keypad_getkey(void)
 {
     2e6:	ef 92       	push	r14
     2e8:	ff 92       	push	r15
     2ea:	0f 93       	push	r16
     2ec:	1f 93       	push	r17
     2ee:	cf 93       	push	r28
     2f0:	df 93       	push	r29
     2f2:	cd b7       	in	r28, 0x3d	; 61
     2f4:	de b7       	in	r29, 0x3e	; 62
     2f6:	29 97       	sbiw	r28, 0x09	; 9
     2f8:	0f b6       	in	r0, 0x3f	; 63
     2fa:	f8 94       	cli
     2fc:	de bf       	out	0x3e, r29	; 62
     2fe:	0f be       	out	0x3f, r0	; 63
     300:	cd bf       	out	0x3d, r28	; 61
   uint8_t volatile col_index=0;
     302:	19 82       	std	Y+1, r1	; 0x01
   uint8_t volatile row_index=0;
     304:	1a 82       	std	Y+2, r1	; 0x02
   uint8_t volatile read_value=0;
     306:	1b 82       	std	Y+3, r1	; 0x03
   uint8_t volatile read_key=0xFF;
     308:	8f ef       	ldi	r24, 0xFF	; 255
     30a:	8c 83       	std	Y+4, r24	; 0x04
   GPIO_Read_Param_t  keypadRowParam;
   GPIO_Write_Param_t keypadColParam;
   //char x[10]={0};
  
   for (col_index=0;col_index<Col_numbers;col_index++)
     30c:	19 82       	std	Y+1, r1	; 0x01
     30e:	89 81       	ldd	r24, Y+1	; 0x01
     310:	84 30       	cpi	r24, 0x04	; 4
     312:	08 f0       	brcs	.+2      	; 0x316 <Keypad_getkey+0x30>
     314:	e8 c0       	rjmp	.+464    	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
   {
	
	
	 /* Put high on the last column */
	 keypadColParam.Port_Name =  g_Keypad_Col_Config[((col_index+Col_numbers)-1)%Col_numbers].PORT_Name;
	 keypadColParam.Mask = (1U<<g_Keypad_Col_Config[((col_index+Col_numbers)-1)%Col_numbers].PIN_Number);
     316:	01 e0       	ldi	r16, 0x01	; 1
     318:	10 e0       	ldi	r17, 0x00	; 0
		keypadRowParam.PIN_Number = g_Keypad_Row_Config[row_index].PIN_Number;
		/* read each row and collect rows status in read_key variable
		   row status is x-ored to be read as 0000 instead of 1111 if now key is pressed
		   and this will make it easy to check each of the rows status individually 
		*/
		read_value |= (uint8_t)(((GPIO_Read(&keypadRowParam))^(1U<<0))<<row_index);
     31a:	ff 24       	eor	r15, r15
     31c:	f3 94       	inc	r15
				
				keypadColParam.Port_Name =  g_Keypad_Col_Config[col_index].PORT_Name;
				keypadColParam.Mask = (1U<<g_Keypad_Col_Config[col_index].PIN_Number);
				keypadColParam.Data = (1U<<g_Keypad_Col_Config[col_index].PIN_Number);
				GPIO_Write(&keypadColParam);
				row_index = Row_numbers;
     31e:	68 94       	set
     320:	ee 24       	eor	r14, r14
     322:	e2 f8       	bld	r14, 2
   for (col_index=0;col_index<Col_numbers;col_index++)
   {
	
	
	 /* Put high on the last column */
	 keypadColParam.Port_Name =  g_Keypad_Col_Config[((col_index+Col_numbers)-1)%Col_numbers].PORT_Name;
     324:	89 81       	ldd	r24, Y+1	; 0x01
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	03 96       	adiw	r24, 0x03	; 3
     32a:	83 70       	andi	r24, 0x03	; 3
     32c:	90 78       	andi	r25, 0x80	; 128
     32e:	99 23       	and	r25, r25
     330:	24 f4       	brge	.+8      	; 0x33a <Keypad_getkey+0x54>
     332:	01 97       	sbiw	r24, 0x01	; 1
     334:	8c 6f       	ori	r24, 0xFC	; 252
     336:	9f 6f       	ori	r25, 0xFF	; 255
     338:	01 96       	adiw	r24, 0x01	; 1
     33a:	88 0f       	add	r24, r24
     33c:	99 1f       	adc	r25, r25
     33e:	fc 01       	movw	r30, r24
     340:	ed 57       	subi	r30, 0x7D	; 125
     342:	ff 4f       	sbci	r31, 0xFF	; 255
     344:	80 81       	ld	r24, Z
     346:	8f 83       	std	Y+7, r24	; 0x07
	 keypadColParam.Mask = (1U<<g_Keypad_Col_Config[((col_index+Col_numbers)-1)%Col_numbers].PIN_Number);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	90 e0       	ldi	r25, 0x00	; 0
     34c:	03 96       	adiw	r24, 0x03	; 3
     34e:	83 70       	andi	r24, 0x03	; 3
     350:	90 78       	andi	r25, 0x80	; 128
     352:	99 23       	and	r25, r25
     354:	24 f4       	brge	.+8      	; 0x35e <Keypad_getkey+0x78>
     356:	01 97       	sbiw	r24, 0x01	; 1
     358:	8c 6f       	ori	r24, 0xFC	; 252
     35a:	9f 6f       	ori	r25, 0xFF	; 255
     35c:	01 96       	adiw	r24, 0x01	; 1
     35e:	88 0f       	add	r24, r24
     360:	99 1f       	adc	r25, r25
     362:	fc 01       	movw	r30, r24
     364:	ed 57       	subi	r30, 0x7D	; 125
     366:	ff 4f       	sbci	r31, 0xFF	; 255
     368:	c8 01       	movw	r24, r16
     36a:	01 80       	ldd	r0, Z+1	; 0x01
     36c:	02 c0       	rjmp	.+4      	; 0x372 <Keypad_getkey+0x8c>
     36e:	88 0f       	add	r24, r24
     370:	99 1f       	adc	r25, r25
     372:	0a 94       	dec	r0
     374:	e2 f7       	brpl	.-8      	; 0x36e <Keypad_getkey+0x88>
     376:	88 87       	std	Y+8, r24	; 0x08
	 keypadColParam.Data = (1U<<g_Keypad_Col_Config[((col_index+Col_numbers)-1)%Col_numbers].PIN_Number);
     378:	89 81       	ldd	r24, Y+1	; 0x01
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	03 96       	adiw	r24, 0x03	; 3
     37e:	83 70       	andi	r24, 0x03	; 3
     380:	90 78       	andi	r25, 0x80	; 128
     382:	99 23       	and	r25, r25
     384:	24 f4       	brge	.+8      	; 0x38e <Keypad_getkey+0xa8>
     386:	01 97       	sbiw	r24, 0x01	; 1
     388:	8c 6f       	ori	r24, 0xFC	; 252
     38a:	9f 6f       	ori	r25, 0xFF	; 255
     38c:	01 96       	adiw	r24, 0x01	; 1
     38e:	88 0f       	add	r24, r24
     390:	99 1f       	adc	r25, r25
     392:	fc 01       	movw	r30, r24
     394:	ed 57       	subi	r30, 0x7D	; 125
     396:	ff 4f       	sbci	r31, 0xFF	; 255
     398:	c8 01       	movw	r24, r16
     39a:	01 80       	ldd	r0, Z+1	; 0x01
     39c:	02 c0       	rjmp	.+4      	; 0x3a2 <Keypad_getkey+0xbc>
     39e:	88 0f       	add	r24, r24
     3a0:	99 1f       	adc	r25, r25
     3a2:	0a 94       	dec	r0
     3a4:	e2 f7       	brpl	.-8      	; 0x39e <Keypad_getkey+0xb8>
     3a6:	89 87       	std	Y+9, r24	; 0x09
	 GPIO_Write(&keypadColParam);
     3a8:	ce 01       	movw	r24, r28
     3aa:	07 96       	adiw	r24, 0x07	; 7
     3ac:	0e 94 2e 05 	call	0xa5c	; 0xa5c <GPIO_Write>

	  /* Put low on the current column */
	  keypadColParam.Port_Name =  g_Keypad_Col_Config[col_index].PORT_Name;
     3b0:	e9 81       	ldd	r30, Y+1	; 0x01
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	ee 0f       	add	r30, r30
     3b6:	ff 1f       	adc	r31, r31
     3b8:	ed 57       	subi	r30, 0x7D	; 125
     3ba:	ff 4f       	sbci	r31, 0xFF	; 255
     3bc:	80 81       	ld	r24, Z
     3be:	8f 83       	std	Y+7, r24	; 0x07
	  keypadColParam.Mask = (1U<<g_Keypad_Col_Config[col_index].PIN_Number);
     3c0:	e9 81       	ldd	r30, Y+1	; 0x01
     3c2:	f0 e0       	ldi	r31, 0x00	; 0
     3c4:	ee 0f       	add	r30, r30
     3c6:	ff 1f       	adc	r31, r31
     3c8:	ed 57       	subi	r30, 0x7D	; 125
     3ca:	ff 4f       	sbci	r31, 0xFF	; 255
     3cc:	c8 01       	movw	r24, r16
     3ce:	01 80       	ldd	r0, Z+1	; 0x01
     3d0:	02 c0       	rjmp	.+4      	; 0x3d6 <Keypad_getkey+0xf0>
     3d2:	88 0f       	add	r24, r24
     3d4:	99 1f       	adc	r25, r25
     3d6:	0a 94       	dec	r0
     3d8:	e2 f7       	brpl	.-8      	; 0x3d2 <Keypad_getkey+0xec>
     3da:	88 87       	std	Y+8, r24	; 0x08
	  keypadColParam.Data = 0U;
     3dc:	19 86       	std	Y+9, r1	; 0x09
	  
	  GPIO_Write(&keypadColParam);
     3de:	ce 01       	movw	r24, r28
     3e0:	07 96       	adiw	r24, 0x07	; 7
     3e2:	0e 94 2e 05 	call	0xa5c	; 0xa5c <GPIO_Write>
	// itoa(PIND,x,2);
	 //LCD_Write_String(x);
	 //_delay_ms(100);

	  /* Read all rows */
	  asm("NOP");
     3e6:	00 00       	nop
	  //asm("NOP");
	  read_value =0;
     3e8:	1b 82       	std	Y+3, r1	; 0x03
	  for (row_index=0;row_index<Row_numbers;row_index++)
     3ea:	1a 82       	std	Y+2, r1	; 0x02
     3ec:	8a 81       	ldd	r24, Y+2	; 0x02
     3ee:	84 30       	cpi	r24, 0x04	; 4
     3f0:	28 f5       	brcc	.+74     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
	  {
		
		keypadRowParam.Port_Name = g_Keypad_Row_Config[row_index].PORT_Name;
     3f2:	ea 81       	ldd	r30, Y+2	; 0x02
     3f4:	f0 e0       	ldi	r31, 0x00	; 0
     3f6:	ee 0f       	add	r30, r30
     3f8:	ff 1f       	adc	r31, r31
     3fa:	e5 58       	subi	r30, 0x85	; 133
     3fc:	ff 4f       	sbci	r31, 0xFF	; 255
     3fe:	80 81       	ld	r24, Z
     400:	8d 83       	std	Y+5, r24	; 0x05
		keypadRowParam.PIN_Number = g_Keypad_Row_Config[row_index].PIN_Number;
     402:	ea 81       	ldd	r30, Y+2	; 0x02
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	ee 0f       	add	r30, r30
     408:	ff 1f       	adc	r31, r31
     40a:	e5 58       	subi	r30, 0x85	; 133
     40c:	ff 4f       	sbci	r31, 0xFF	; 255
     40e:	81 81       	ldd	r24, Z+1	; 0x01
     410:	8e 83       	std	Y+6, r24	; 0x06
		/* read each row and collect rows status in read_key variable
		   row status is x-ored to be read as 0000 instead of 1111 if now key is pressed
		   and this will make it easy to check each of the rows status individually 
		*/
		read_value |= (uint8_t)(((GPIO_Read(&keypadRowParam))^(1U<<0))<<row_index);
     412:	ce 01       	movw	r24, r28
     414:	05 96       	adiw	r24, 0x05	; 5
     416:	0e 94 64 05 	call	0xac8	; 0xac8 <GPIO_Read>
     41a:	3a 81       	ldd	r19, Y+2	; 0x02
     41c:	2b 81       	ldd	r18, Y+3	; 0x03
     41e:	8f 25       	eor	r24, r15
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	02 c0       	rjmp	.+4      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	3a 95       	dec	r19
     42a:	e2 f7       	brpl	.-8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
     42c:	82 2b       	or	r24, r18
     42e:	8b 83       	std	Y+3, r24	; 0x03

	  /* Read all rows */
	  asm("NOP");
	  //asm("NOP");
	  read_value =0;
	  for (row_index=0;row_index<Row_numbers;row_index++)
     430:	8a 81       	ldd	r24, Y+2	; 0x02
     432:	8f 5f       	subi	r24, 0xFF	; 255
     434:	8a 83       	std	Y+2, r24	; 0x02
     436:	8a 81       	ldd	r24, Y+2	; 0x02
     438:	84 30       	cpi	r24, 0x04	; 4
     43a:	d8 f2       	brcs	.-74     	; 0x3f2 <Keypad_getkey+0x10c>
		read_value |= (uint8_t)(((GPIO_Read(&keypadRowParam))^(1U<<0))<<row_index);
	  }
	 
	  
	    /* get key value from user's keypad map */
		for (row_index=0;row_index<Row_numbers;row_index++)
     43c:	1a 82       	std	Y+2, r1	; 0x02
     43e:	8a 81       	ldd	r24, Y+2	; 0x02
     440:	84 30       	cpi	r24, 0x04	; 4
     442:	08 f0       	brcs	.+2      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     444:	49 c0       	rjmp	.+146    	; 0x4d8 <__LOCK_REGION_LENGTH__+0xd8>
		{
			 if (read_value == (1U<<row_index))
     446:	8b 81       	ldd	r24, Y+3	; 0x03
     448:	2a 81       	ldd	r18, Y+2	; 0x02
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	a8 01       	movw	r20, r16
     44e:	02 c0       	rjmp	.+4      	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
     450:	44 0f       	add	r20, r20
     452:	55 1f       	adc	r21, r21
     454:	2a 95       	dec	r18
     456:	e2 f7       	brpl	.-8      	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
     458:	84 17       	cp	r24, r20
     45a:	95 07       	cpc	r25, r21
     45c:	b1 f5       	brne	.+108    	; 0x4ca <__LOCK_REGION_LENGTH__+0xca>
			 {
				read_key = g_Keypad_Map[row_index][col_index];
     45e:	8a 81       	ldd	r24, Y+2	; 0x02
     460:	e9 81       	ldd	r30, Y+1	; 0x01
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	54 e0       	ldi	r21, 0x04	; 4
     466:	85 9f       	mul	r24, r21
     468:	e0 0d       	add	r30, r0
     46a:	f1 1d       	adc	r31, r1
     46c:	11 24       	eor	r1, r1
     46e:	e5 59       	subi	r30, 0x95	; 149
     470:	ff 4f       	sbci	r31, 0xFF	; 255
     472:	80 81       	ld	r24, Z
     474:	8c 83       	std	Y+4, r24	; 0x04
				
				keypadColParam.Port_Name =  g_Keypad_Col_Config[col_index].PORT_Name;
     476:	e9 81       	ldd	r30, Y+1	; 0x01
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	ee 0f       	add	r30, r30
     47c:	ff 1f       	adc	r31, r31
     47e:	ed 57       	subi	r30, 0x7D	; 125
     480:	ff 4f       	sbci	r31, 0xFF	; 255
     482:	80 81       	ld	r24, Z
     484:	8f 83       	std	Y+7, r24	; 0x07
				keypadColParam.Mask = (1U<<g_Keypad_Col_Config[col_index].PIN_Number);
     486:	e9 81       	ldd	r30, Y+1	; 0x01
     488:	f0 e0       	ldi	r31, 0x00	; 0
     48a:	ee 0f       	add	r30, r30
     48c:	ff 1f       	adc	r31, r31
     48e:	ed 57       	subi	r30, 0x7D	; 125
     490:	ff 4f       	sbci	r31, 0xFF	; 255
     492:	c8 01       	movw	r24, r16
     494:	01 80       	ldd	r0, Z+1	; 0x01
     496:	02 c0       	rjmp	.+4      	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
     498:	88 0f       	add	r24, r24
     49a:	99 1f       	adc	r25, r25
     49c:	0a 94       	dec	r0
     49e:	e2 f7       	brpl	.-8      	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
     4a0:	88 87       	std	Y+8, r24	; 0x08
				keypadColParam.Data = (1U<<g_Keypad_Col_Config[col_index].PIN_Number);
     4a2:	e9 81       	ldd	r30, Y+1	; 0x01
     4a4:	f0 e0       	ldi	r31, 0x00	; 0
     4a6:	ee 0f       	add	r30, r30
     4a8:	ff 1f       	adc	r31, r31
     4aa:	ed 57       	subi	r30, 0x7D	; 125
     4ac:	ff 4f       	sbci	r31, 0xFF	; 255
     4ae:	c8 01       	movw	r24, r16
     4b0:	01 80       	ldd	r0, Z+1	; 0x01
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
     4b4:	88 0f       	add	r24, r24
     4b6:	99 1f       	adc	r25, r25
     4b8:	0a 94       	dec	r0
     4ba:	e2 f7       	brpl	.-8      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
     4bc:	89 87       	std	Y+9, r24	; 0x09
				GPIO_Write(&keypadColParam);
     4be:	ce 01       	movw	r24, r28
     4c0:	07 96       	adiw	r24, 0x07	; 7
     4c2:	0e 94 2e 05 	call	0xa5c	; 0xa5c <GPIO_Write>
				row_index = Row_numbers;
     4c6:	ea 82       	std	Y+2, r14	; 0x02
				col_index= Col_numbers;
     4c8:	e9 82       	std	Y+1, r14	; 0x01
		read_value |= (uint8_t)(((GPIO_Read(&keypadRowParam))^(1U<<0))<<row_index);
	  }
	 
	  
	    /* get key value from user's keypad map */
		for (row_index=0;row_index<Row_numbers;row_index++)
     4ca:	8a 81       	ldd	r24, Y+2	; 0x02
     4cc:	8f 5f       	subi	r24, 0xFF	; 255
     4ce:	8a 83       	std	Y+2, r24	; 0x02
     4d0:	8a 81       	ldd	r24, Y+2	; 0x02
     4d2:	84 30       	cpi	r24, 0x04	; 4
     4d4:	08 f4       	brcc	.+2      	; 0x4d8 <__LOCK_REGION_LENGTH__+0xd8>
     4d6:	b7 cf       	rjmp	.-146    	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
   uint8_t volatile read_key=0xFF;
   GPIO_Read_Param_t  keypadRowParam;
   GPIO_Write_Param_t keypadColParam;
   //char x[10]={0};
  
   for (col_index=0;col_index<Col_numbers;col_index++)
     4d8:	89 81       	ldd	r24, Y+1	; 0x01
     4da:	8f 5f       	subi	r24, 0xFF	; 255
     4dc:	89 83       	std	Y+1, r24	; 0x01
     4de:	89 81       	ldd	r24, Y+1	; 0x01
     4e0:	84 30       	cpi	r24, 0x04	; 4
     4e2:	08 f4       	brcc	.+2      	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
     4e4:	1f cf       	rjmp	.-450    	; 0x324 <Keypad_getkey+0x3e>
		

	 
    }

	return read_key;
     4e6:	8c 81       	ldd	r24, Y+4	; 0x04
     4e8:	29 96       	adiw	r28, 0x09	; 9
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	f8 94       	cli
     4ee:	de bf       	out	0x3e, r29	; 62
     4f0:	0f be       	out	0x3f, r0	; 63
     4f2:	cd bf       	out	0x3d, r28	; 61
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	ff 90       	pop	r15
     4fe:	ef 90       	pop	r14
     500:	08 95       	ret

00000502 <LCD_READ>:
 }

 /**********************************************/

 void LCD_Write_float( float  float_value)
 {
     502:	c2 9a       	sbi	0x18, 2	; 24
     504:	85 e0       	ldi	r24, 0x05	; 5
     506:	8a 95       	dec	r24
     508:	f1 f7       	brne	.-4      	; 0x506 <LCD_READ+0x4>
     50a:	00 00       	nop
     50c:	c2 98       	cbi	0x18, 2	; 24
     50e:	8f e6       	ldi	r24, 0x6F	; 111
     510:	97 e1       	ldi	r25, 0x17	; 23
     512:	01 97       	sbiw	r24, 0x01	; 1
     514:	f1 f7       	brne	.-4      	; 0x512 <LCD_READ+0x10>
     516:	00 c0       	rjmp	.+0      	; 0x518 <LCD_READ+0x16>
     518:	00 00       	nop
     51a:	08 95       	ret

0000051c <LCD_Write_4bit_mode>:
     51c:	cf 93       	push	r28
     51e:	c8 2f       	mov	r28, r24
     520:	88 23       	and	r24, r24
     522:	14 f4       	brge	.+4      	; 0x528 <LCD_Write_4bit_mode+0xc>
     524:	c6 9a       	sbi	0x18, 6	; 24
     526:	01 c0       	rjmp	.+2      	; 0x52a <LCD_Write_4bit_mode+0xe>
     528:	c6 98       	cbi	0x18, 6	; 24
     52a:	c6 ff       	sbrs	r28, 6
     52c:	02 c0       	rjmp	.+4      	; 0x532 <LCD_Write_4bit_mode+0x16>
     52e:	c5 9a       	sbi	0x18, 5	; 24
     530:	01 c0       	rjmp	.+2      	; 0x534 <LCD_Write_4bit_mode+0x18>
     532:	c5 98       	cbi	0x18, 5	; 24
     534:	c5 ff       	sbrs	r28, 5
     536:	02 c0       	rjmp	.+4      	; 0x53c <LCD_Write_4bit_mode+0x20>
     538:	c4 9a       	sbi	0x18, 4	; 24
     53a:	01 c0       	rjmp	.+2      	; 0x53e <LCD_Write_4bit_mode+0x22>
     53c:	c4 98       	cbi	0x18, 4	; 24
     53e:	c4 ff       	sbrs	r28, 4
     540:	02 c0       	rjmp	.+4      	; 0x546 <LCD_Write_4bit_mode+0x2a>
     542:	c3 9a       	sbi	0x18, 3	; 24
     544:	01 c0       	rjmp	.+2      	; 0x548 <LCD_Write_4bit_mode+0x2c>
     546:	c3 98       	cbi	0x18, 3	; 24
     548:	0e 94 81 02 	call	0x502	; 0x502 <LCD_READ>
     54c:	c3 ff       	sbrs	r28, 3
     54e:	02 c0       	rjmp	.+4      	; 0x554 <LCD_Write_4bit_mode+0x38>
     550:	c6 9a       	sbi	0x18, 6	; 24
     552:	01 c0       	rjmp	.+2      	; 0x556 <LCD_Write_4bit_mode+0x3a>
     554:	c6 98       	cbi	0x18, 6	; 24
     556:	c2 ff       	sbrs	r28, 2
     558:	02 c0       	rjmp	.+4      	; 0x55e <LCD_Write_4bit_mode+0x42>
     55a:	c5 9a       	sbi	0x18, 5	; 24
     55c:	01 c0       	rjmp	.+2      	; 0x560 <LCD_Write_4bit_mode+0x44>
     55e:	c5 98       	cbi	0x18, 5	; 24
     560:	c1 ff       	sbrs	r28, 1
     562:	02 c0       	rjmp	.+4      	; 0x568 <LCD_Write_4bit_mode+0x4c>
     564:	c4 9a       	sbi	0x18, 4	; 24
     566:	01 c0       	rjmp	.+2      	; 0x56a <LCD_Write_4bit_mode+0x4e>
     568:	c4 98       	cbi	0x18, 4	; 24
     56a:	c0 ff       	sbrs	r28, 0
     56c:	02 c0       	rjmp	.+4      	; 0x572 <LCD_Write_4bit_mode+0x56>
     56e:	c3 9a       	sbi	0x18, 3	; 24
     570:	01 c0       	rjmp	.+2      	; 0x574 <LCD_Write_4bit_mode+0x58>
     572:	c3 98       	cbi	0x18, 3	; 24
     574:	0e 94 81 02 	call	0x502	; 0x502 <LCD_READ>
     578:	cf 91       	pop	r28
     57a:	08 95       	ret

0000057c <LCD_Write_Command>:
     57c:	c0 98       	cbi	0x18, 0	; 24
     57e:	c1 98       	cbi	0x18, 1	; 24
     580:	0e 94 8e 02 	call	0x51c	; 0x51c <LCD_Write_4bit_mode>
     584:	08 95       	ret

00000586 <LCD_Go_To_X_Y>:
     586:	81 11       	cpse	r24, r1
     588:	05 c0       	rjmp	.+10     	; 0x594 <LCD_Go_To_X_Y+0xe>
     58a:	8f e7       	ldi	r24, 0x7F	; 127
     58c:	86 0f       	add	r24, r22
     58e:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
     592:	08 95       	ret
     594:	81 30       	cpi	r24, 0x01	; 1
     596:	21 f4       	brne	.+8      	; 0x5a0 <LCD_Go_To_X_Y+0x1a>
     598:	8f eb       	ldi	r24, 0xBF	; 191
     59a:	86 0f       	add	r24, r22
     59c:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
     5a0:	08 95       	ret

000005a2 <LCD_Write_Character>:
     5a2:	c0 9a       	sbi	0x18, 0	; 24
     5a4:	c1 98       	cbi	0x18, 1	; 24
     5a6:	0e 94 8e 02 	call	0x51c	; 0x51c <LCD_Write_4bit_mode>
     5aa:	08 95       	ret

000005ac <LCD_Write_String>:
     5ac:	cf 93       	push	r28
     5ae:	df 93       	push	r29
     5b0:	ec 01       	movw	r28, r24
     5b2:	88 81       	ld	r24, Y
     5b4:	88 23       	and	r24, r24
     5b6:	31 f0       	breq	.+12     	; 0x5c4 <LCD_Write_String+0x18>
     5b8:	21 96       	adiw	r28, 0x01	; 1
     5ba:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <LCD_Write_Character>
     5be:	89 91       	ld	r24, Y+
     5c0:	81 11       	cpse	r24, r1
     5c2:	fb cf       	rjmp	.-10     	; 0x5ba <LCD_Write_String+0xe>
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	08 95       	ret

000005ca <LCD_Initialization>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5ca:	8f e2       	ldi	r24, 0x2F	; 47
     5cc:	95 e7       	ldi	r25, 0x75	; 117
     5ce:	01 97       	sbiw	r24, 0x01	; 1
     5d0:	f1 f7       	brne	.-4      	; 0x5ce <LCD_Initialization+0x4>
     5d2:	00 c0       	rjmp	.+0      	; 0x5d4 <LCD_Initialization+0xa>
     5d4:	00 00       	nop
 void LCD_Initialization(void)
 {
     /* delay for 15 ms for the LCD to power up */
	 _delay_ms(15);
	 /* set the direction for the LCD pins */
	 LCD_RS_DDR |=(1U<<LCD_RS_PIN);
     5d6:	b8 9a       	sbi	0x17, 0	; 23
	 LCD_RW_DDR |=(1U<<LCD_RW_PIN);
     5d8:	b9 9a       	sbi	0x17, 1	; 23
	 LCD_EN_DDR |=(1U<<LCD_EN_PIN);
     5da:	ba 9a       	sbi	0x17, 2	; 23
	 LCD_D7_DDR |=(1U<<LCD_D7_PIN);
     5dc:	be 9a       	sbi	0x17, 6	; 23
	 LCD_D6_DDR |=(1U<<LCD_D6_PIN);
     5de:	bd 9a       	sbi	0x17, 5	; 23
	 LCD_D5_DDR |=(1U<<LCD_D5_PIN);
     5e0:	bc 9a       	sbi	0x17, 4	; 23
	 LCD_D4_DDR |=(1U<<LCD_D4_PIN);
     5e2:	bb 9a       	sbi	0x17, 3	; 23
	 /* send the initialization values as in data sheet (as commands) */
	 LCD_Write_Command(0x33U);  /* Initialization */
     5e4:	83 e3       	ldi	r24, 0x33	; 51
     5e6:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	 LCD_Write_Command(0x32U);	/* Initialization */
     5ea:	82 e3       	ldi	r24, 0x32	; 50
     5ec:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	 LCD_Write_Command(0x28U);	/* Function Set: 4-bit, 2 Line, 5x7 Dots */
     5f0:	88 e2       	ldi	r24, 0x28	; 40
     5f2:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	 LCD_Write_Command(0x0cU);	/* Display on ,cursor off */
     5f6:	8c e0       	ldi	r24, 0x0C	; 12
     5f8:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	 LCD_Write_Command(0x01U);  /* Clear display , Cursor home */
     5fc:	81 e0       	ldi	r24, 0x01	; 1
     5fe:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
     602:	08 95       	ret

00000604 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     604:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     606:	03 96       	adiw	r24, 0x03	; 3
     608:	92 83       	std	Z+2, r25	; 0x02
     60a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     60c:	2f ef       	ldi	r18, 0xFF	; 255
     60e:	3f ef       	ldi	r19, 0xFF	; 255
     610:	34 83       	std	Z+4, r19	; 0x04
     612:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     614:	96 83       	std	Z+6, r25	; 0x06
     616:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     618:	90 87       	std	Z+8, r25	; 0x08
     61a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     61c:	10 82       	st	Z, r1
     61e:	08 95       	ret

00000620 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     620:	fc 01       	movw	r30, r24
     622:	11 86       	std	Z+9, r1	; 0x09
     624:	10 86       	std	Z+8, r1	; 0x08
     626:	08 95       	ret

00000628 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     628:	cf 93       	push	r28
     62a:	df 93       	push	r29
     62c:	9c 01       	movw	r18, r24
     62e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     630:	dc 01       	movw	r26, r24
     632:	11 96       	adiw	r26, 0x01	; 1
     634:	cd 91       	ld	r28, X+
     636:	dc 91       	ld	r29, X
     638:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     63a:	d3 83       	std	Z+3, r29	; 0x03
     63c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     63e:	8c 81       	ldd	r24, Y+4	; 0x04
     640:	9d 81       	ldd	r25, Y+5	; 0x05
     642:	95 83       	std	Z+5, r25	; 0x05
     644:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     646:	8c 81       	ldd	r24, Y+4	; 0x04
     648:	9d 81       	ldd	r25, Y+5	; 0x05
     64a:	dc 01       	movw	r26, r24
     64c:	13 96       	adiw	r26, 0x03	; 3
     64e:	7c 93       	st	X, r23
     650:	6e 93       	st	-X, r22
     652:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     654:	7d 83       	std	Y+5, r23	; 0x05
     656:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     658:	31 87       	std	Z+9, r19	; 0x09
     65a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     65c:	f9 01       	movw	r30, r18
     65e:	80 81       	ld	r24, Z
     660:	8f 5f       	subi	r24, 0xFF	; 255
     662:	80 83       	st	Z, r24
}
     664:	df 91       	pop	r29
     666:	cf 91       	pop	r28
     668:	08 95       	ret

0000066a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     670:	48 81       	ld	r20, Y
     672:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     674:	4f 3f       	cpi	r20, 0xFF	; 255
     676:	2f ef       	ldi	r18, 0xFF	; 255
     678:	52 07       	cpc	r21, r18
     67a:	21 f4       	brne	.+8      	; 0x684 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     67c:	fc 01       	movw	r30, r24
     67e:	a7 81       	ldd	r26, Z+7	; 0x07
     680:	b0 85       	ldd	r27, Z+8	; 0x08
     682:	0d c0       	rjmp	.+26     	; 0x69e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     684:	dc 01       	movw	r26, r24
     686:	13 96       	adiw	r26, 0x03	; 3
     688:	01 c0       	rjmp	.+2      	; 0x68c <vListInsert+0x22>
     68a:	df 01       	movw	r26, r30
     68c:	12 96       	adiw	r26, 0x02	; 2
     68e:	ed 91       	ld	r30, X+
     690:	fc 91       	ld	r31, X
     692:	13 97       	sbiw	r26, 0x03	; 3
     694:	20 81       	ld	r18, Z
     696:	31 81       	ldd	r19, Z+1	; 0x01
     698:	42 17       	cp	r20, r18
     69a:	53 07       	cpc	r21, r19
     69c:	b0 f7       	brcc	.-20     	; 0x68a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     69e:	12 96       	adiw	r26, 0x02	; 2
     6a0:	ed 91       	ld	r30, X+
     6a2:	fc 91       	ld	r31, X
     6a4:	13 97       	sbiw	r26, 0x03	; 3
     6a6:	fb 83       	std	Y+3, r31	; 0x03
     6a8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     6aa:	d5 83       	std	Z+5, r29	; 0x05
     6ac:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     6ae:	bd 83       	std	Y+5, r27	; 0x05
     6b0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     6b2:	13 96       	adiw	r26, 0x03	; 3
     6b4:	dc 93       	st	X, r29
     6b6:	ce 93       	st	-X, r28
     6b8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ba:	99 87       	std	Y+9, r25	; 0x09
     6bc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6be:	fc 01       	movw	r30, r24
     6c0:	20 81       	ld	r18, Z
     6c2:	2f 5f       	subi	r18, 0xFF	; 255
     6c4:	20 83       	st	Z, r18
}
     6c6:	df 91       	pop	r29
     6c8:	cf 91       	pop	r28
     6ca:	08 95       	ret

000006cc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6d2:	a0 85       	ldd	r26, Z+8	; 0x08
     6d4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6d6:	c2 81       	ldd	r28, Z+2	; 0x02
     6d8:	d3 81       	ldd	r29, Z+3	; 0x03
     6da:	84 81       	ldd	r24, Z+4	; 0x04
     6dc:	95 81       	ldd	r25, Z+5	; 0x05
     6de:	9d 83       	std	Y+5, r25	; 0x05
     6e0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6e2:	c4 81       	ldd	r28, Z+4	; 0x04
     6e4:	d5 81       	ldd	r29, Z+5	; 0x05
     6e6:	82 81       	ldd	r24, Z+2	; 0x02
     6e8:	93 81       	ldd	r25, Z+3	; 0x03
     6ea:	9b 83       	std	Y+3, r25	; 0x03
     6ec:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6ee:	11 96       	adiw	r26, 0x01	; 1
     6f0:	cd 91       	ld	r28, X+
     6f2:	dc 91       	ld	r29, X
     6f4:	12 97       	sbiw	r26, 0x02	; 2
     6f6:	ce 17       	cp	r28, r30
     6f8:	df 07       	cpc	r29, r31
     6fa:	31 f4       	brne	.+12     	; 0x708 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6fc:	8c 81       	ldd	r24, Y+4	; 0x04
     6fe:	9d 81       	ldd	r25, Y+5	; 0x05
     700:	12 96       	adiw	r26, 0x02	; 2
     702:	9c 93       	st	X, r25
     704:	8e 93       	st	-X, r24
     706:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     708:	11 86       	std	Z+9, r1	; 0x09
     70a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     70c:	8c 91       	ld	r24, X
     70e:	81 50       	subi	r24, 0x01	; 1
     710:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     712:	df 91       	pop	r29
     714:	cf 91       	pop	r28
     716:	08 95       	ret

00000718 <vTask_KeyPad>:
xQueueHandle LCD_Queue = NULL;
xSemaphoreHandle CheckPasswordSemaphore = NULL;
uint8_t g_Password[10]={0};
uint8_t g_CurrentPassword[]="12345678";
void vTask_KeyPad(void  *vpParamter)
{
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	1f 92       	push	r1
     71e:	cd b7       	in	r28, 0x3d	; 61
     720:	de b7       	in	r29, 0x3e	; 62
	uint8_t KeypadLastState = NOTPRESSED;
	uint8_t KeypadKey = 0;
     722:	19 82       	std	Y+1, r1	; 0x01
	Keypad_Init();
     724:	0e 94 16 01 	call	0x22c	; 0x22c <Keypad_Init>
	LCD_Write_Command(LCD_CLEAR_CMD);
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	LCD_Write_String("keypadTask");
     72e:	8b e8       	ldi	r24, 0x8B	; 139
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
     736:	2f ef       	ldi	r18, 0xFF	; 255
     738:	89 e6       	ldi	r24, 0x69	; 105
     73a:	98 e1       	ldi	r25, 0x18	; 24
     73c:	21 50       	subi	r18, 0x01	; 1
     73e:	80 40       	sbci	r24, 0x00	; 0
     740:	90 40       	sbci	r25, 0x00	; 0
     742:	e1 f7       	brne	.-8      	; 0x73c <vTask_KeyPad+0x24>
     744:	00 c0       	rjmp	.+0      	; 0x746 <vTask_KeyPad+0x2e>
     746:	00 00       	nop
xSemaphoreHandle CheckPasswordSemaphore = NULL;
uint8_t g_Password[10]={0};
uint8_t g_CurrentPassword[]="12345678";
void vTask_KeyPad(void  *vpParamter)
{
	uint8_t KeypadLastState = NOTPRESSED;
     748:	1f ef       	ldi	r17, 0xFF	; 255
	LCD_Write_Command(LCD_CLEAR_CMD);
	LCD_Write_String("keypadTask");
	_delay_ms(1000);
	while(1)
	{
		KeypadKey = Keypad_getkey();
     74a:	0e 94 73 01 	call	0x2e6	; 0x2e6 <Keypad_getkey>
     74e:	89 83       	std	Y+1, r24	; 0x01
		if (KeypadKey !=NOTPRESSED && KeypadLastState == NOTPRESSED)
     750:	8f 3f       	cpi	r24, 0xFF	; 255
     752:	71 f0       	breq	.+28     	; 0x770 <vTask_KeyPad+0x58>
     754:	1f 3f       	cpi	r17, 0xFF	; 255
     756:	61 f4       	brne	.+24     	; 0x770 <vTask_KeyPad+0x58>
		{
		
			xQueueSend(LCD_Queue,(void *)&KeypadKey,0); 
     758:	20 e0       	ldi	r18, 0x00	; 0
     75a:	40 e0       	ldi	r20, 0x00	; 0
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	be 01       	movw	r22, r28
     760:	6f 5f       	subi	r22, 0xFF	; 255
     762:	7f 4f       	sbci	r23, 0xFF	; 255
     764:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <LCD_Queue>
     768:	90 91 e0 04 	lds	r25, 0x04E0	; 0x8004e0 <LCD_Queue+0x1>
     76c:	0e 94 47 08 	call	0x108e	; 0x108e <xQueueGenericSend>
		    
		} 
		KeypadLastState = KeypadKey;
     770:	19 81       	ldd	r17, Y+1	; 0x01
			
		vTaskDelay(50);
     772:	82 e3       	ldi	r24, 0x32	; 50
     774:	90 e0       	ldi	r25, 0x00	; 0
     776:	0e 94 a6 0c 	call	0x194c	; 0x194c <vTaskDelay>
	}
     77a:	e7 cf       	rjmp	.-50     	; 0x74a <vTask_KeyPad+0x32>

0000077c <vTask_LCD>:
	
}

void vTask_LCD(void  *vpParamter)
{
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	1f 92       	push	r1
     782:	cd b7       	in	r28, 0x3d	; 61
     784:	de b7       	in	r29, 0x3e	; 62
	uint8_t KeypadKey = 0;
     786:	19 82       	std	Y+1, r1	; 0x01
	uint8_t passwordIndex = 0;
	BaseType_t queueState=pdFALSE;
	LCD_State_t LCD_CurrentState = Welcome;
	LCD_Initialization();
     788:	0e 94 e5 02 	call	0x5ca	; 0x5ca <LCD_Initialization>
	LCD_Write_Command(LCD_CLEAR_CMD);
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	LCD_Write_String("Welcome");
     792:	86 e9       	ldi	r24, 0x96	; 150
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
     79a:	2f ef       	ldi	r18, 0xFF	; 255
     79c:	89 e6       	ldi	r24, 0x69	; 105
     79e:	98 e1       	ldi	r25, 0x18	; 24
     7a0:	21 50       	subi	r18, 0x01	; 1
     7a2:	80 40       	sbci	r24, 0x00	; 0
     7a4:	90 40       	sbci	r25, 0x00	; 0
     7a6:	e1 f7       	brne	.-8      	; 0x7a0 <vTask_LCD+0x24>
     7a8:	00 c0       	rjmp	.+0      	; 0x7aa <vTask_LCD+0x2e>
     7aa:	00 00       	nop
void vTask_LCD(void  *vpParamter)
{
	uint8_t KeypadKey = 0;
	uint8_t passwordIndex = 0;
	BaseType_t queueState=pdFALSE;
	LCD_State_t LCD_CurrentState = Welcome;
     7ac:	10 e0       	ldi	r17, 0x00	; 0
}

void vTask_LCD(void  *vpParamter)
{
	uint8_t KeypadKey = 0;
	uint8_t passwordIndex = 0;
     7ae:	00 e0       	ldi	r16, 0x00	; 0
					break;
					case '#':
					
					// add null to the end of the string
					g_Password[passwordIndex]='\0';
					LCD_CurrentState = Submit;
     7b0:	68 94       	set
     7b2:	ff 24       	eor	r15, r15
     7b4:	f1 f8       	bld	r15, 1
	_delay_ms(1000);
	
	while(1)
	{
		// block on queue for ever
		queueState = xQueueReceive(LCD_Queue,&KeypadKey,5000);
     7b6:	20 e0       	ldi	r18, 0x00	; 0
     7b8:	48 e8       	ldi	r20, 0x88	; 136
     7ba:	53 e1       	ldi	r21, 0x13	; 19
     7bc:	be 01       	movw	r22, r28
     7be:	6f 5f       	subi	r22, 0xFF	; 255
     7c0:	7f 4f       	sbci	r23, 0xFF	; 255
     7c2:	80 91 df 04 	lds	r24, 0x04DF	; 0x8004df <LCD_Queue>
     7c6:	90 91 e0 04 	lds	r25, 0x04E0	; 0x8004e0 <LCD_Queue+0x1>
     7ca:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <xQueueGenericReceive>
		if (queueState==pdPASS)
     7ce:	81 30       	cpi	r24, 0x01	; 1
     7d0:	09 f0       	breq	.+2      	; 0x7d4 <vTask_LCD+0x58>
     7d2:	5c c0       	rjmp	.+184    	; 0x88c <__stack+0x2d>
		{
			switch(LCD_CurrentState)
     7d4:	11 30       	cpi	r17, 0x01	; 1
     7d6:	a9 f0       	breq	.+42     	; 0x802 <vTask_LCD+0x86>
     7d8:	20 f0       	brcs	.+8      	; 0x7e2 <vTask_LCD+0x66>
     7da:	12 30       	cpi	r17, 0x02	; 2
     7dc:	09 f4       	brne	.+2      	; 0x7e0 <vTask_LCD+0x64>
     7de:	4c c0       	rjmp	.+152    	; 0x878 <__stack+0x19>
     7e0:	ea cf       	rjmp	.-44     	; 0x7b6 <vTask_LCD+0x3a>
			{
				case Welcome:
				if (KeypadKey=='#')
     7e2:	89 81       	ldd	r24, Y+1	; 0x01
     7e4:	83 32       	cpi	r24, 0x23	; 35
     7e6:	39 f7       	brne	.-50     	; 0x7b6 <vTask_LCD+0x3a>
				{
					LCD_CurrentState = Recieving;
					LCD_Write_Command(LCD_CLEAR_CMD);
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
					LCD_Write_String("Password:");
     7ee:	8e e9       	ldi	r24, 0x9E	; 158
     7f0:	90 e0       	ldi	r25, 0x00	; 0
     7f2:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
					LCD_Go_To_X_Y(LCD_ROW_2,LCD_POSITION_2);
     7f6:	61 e0       	ldi	r22, 0x01	; 1
     7f8:	81 e0       	ldi	r24, 0x01	; 1
     7fa:	0e 94 c3 02 	call	0x586	; 0x586 <LCD_Go_To_X_Y>
			switch(LCD_CurrentState)
			{
				case Welcome:
				if (KeypadKey=='#')
				{
					LCD_CurrentState = Recieving;
     7fe:	11 e0       	ldi	r17, 0x01	; 1
     800:	da cf       	rjmp	.-76     	; 0x7b6 <vTask_LCD+0x3a>
					LCD_Write_String("Password:");
					LCD_Go_To_X_Y(LCD_ROW_2,LCD_POSITION_2);
				}
				break;
				case Recieving:
				switch(KeypadKey)
     802:	89 81       	ldd	r24, Y+1	; 0x01
     804:	83 32       	cpi	r24, 0x23	; 35
     806:	79 f0       	breq	.+30     	; 0x826 <vTask_LCD+0xaa>
     808:	83 34       	cpi	r24, 0x43	; 67
     80a:	01 f5       	brne	.+64     	; 0x84c <vTask_LCD+0xd0>
				{
					
					case 'C':
					//clear one character from lcd and string
					if (passwordIndex>0)
     80c:	00 23       	and	r16, r16
     80e:	99 f2       	breq	.-90     	; 0x7b6 <vTask_LCD+0x3a>
					{
						passwordIndex--;
     810:	01 50       	subi	r16, 0x01	; 1
						LCD_Write_Command(LCD_CURSOR_SHIFT_LIFT_CMD);
     812:	80 e1       	ldi	r24, 0x10	; 16
     814:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
						LCD_Write_Character(' ');
     818:	80 e2       	ldi	r24, 0x20	; 32
     81a:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <LCD_Write_Character>
						LCD_Write_Command(LCD_CURSOR_SHIFT_LIFT_CMD);
     81e:	80 e1       	ldi	r24, 0x10	; 16
     820:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
     824:	c8 cf       	rjmp	.-112    	; 0x7b6 <vTask_LCD+0x3a>
					
					break;
					case '#':
					
					// add null to the end of the string
					g_Password[passwordIndex]='\0';
     826:	e0 2f       	mov	r30, r16
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	ed 52       	subi	r30, 0x2D	; 45
     82c:	fb 4f       	sbci	r31, 0xFB	; 251
     82e:	10 82       	st	Z, r1
					LCD_CurrentState = Submit;
					// reset index
					passwordIndex = 0;
					//release semaphore to run check Task
					xSemaphoreGive(CheckPasswordSemaphore);
     830:	20 e0       	ldi	r18, 0x00	; 0
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	60 e0       	ldi	r22, 0x00	; 0
     838:	70 e0       	ldi	r23, 0x00	; 0
     83a:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <CheckPasswordSemaphore>
     83e:	90 91 de 04 	lds	r25, 0x04DE	; 0x8004de <CheckPasswordSemaphore+0x1>
     842:	0e 94 47 08 	call	0x108e	; 0x108e <xQueueGenericSend>
					break;
					case '#':
					
					// add null to the end of the string
					g_Password[passwordIndex]='\0';
					LCD_CurrentState = Submit;
     846:	1f 2d       	mov	r17, r15
					// reset index
					passwordIndex = 0;
     848:	00 e0       	ldi	r16, 0x00	; 0
					//release semaphore to run check Task
					xSemaphoreGive(CheckPasswordSemaphore);
					break;
     84a:	b5 cf       	rjmp	.-150    	; 0x7b6 <vTask_LCD+0x3a>
					default:
					// add to string and show on lcd
					// check if index over flow and don't accept other character
					if (passwordIndex<9)
     84c:	09 30       	cpi	r16, 0x09	; 9
     84e:	08 f0       	brcs	.+2      	; 0x852 <vTask_LCD+0xd6>
     850:	b2 cf       	rjmp	.-156    	; 0x7b6 <vTask_LCD+0x3a>
					{
						g_Password[passwordIndex]=KeypadKey;
     852:	e0 2f       	mov	r30, r16
     854:	f0 e0       	ldi	r31, 0x00	; 0
     856:	ed 52       	subi	r30, 0x2D	; 45
     858:	fb 4f       	sbci	r31, 0xFB	; 251
     85a:	80 83       	st	Z, r24
						passwordIndex++;
     85c:	0f 5f       	subi	r16, 0xFF	; 255
						LCD_Write_Character(KeypadKey);
     85e:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <LCD_Write_Character>
						vTaskDelay(200);
     862:	88 ec       	ldi	r24, 0xC8	; 200
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	0e 94 a6 0c 	call	0x194c	; 0x194c <vTaskDelay>
						LCD_Write_Command(LCD_CURSOR_SHIFT_LIFT_CMD);
     86a:	80 e1       	ldi	r24, 0x10	; 16
     86c:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
						LCD_Write_Character('*');
     870:	8a e2       	ldi	r24, 0x2A	; 42
     872:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <LCD_Write_Character>
     876:	9f cf       	rjmp	.-194    	; 0x7b6 <vTask_LCD+0x3a>
				}
				break;
				case Submit:
				LCD_CurrentState = Welcome;
				passwordIndex=0;
				LCD_Write_Command(LCD_CLEAR_CMD);
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
				LCD_Write_String("Welcome");
     87e:	86 e9       	ldi	r24, 0x96	; 150
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
					break;

				}
				break;
				case Submit:
				LCD_CurrentState = Welcome;
     886:	10 e0       	ldi	r17, 0x00	; 0
				passwordIndex=0;
     888:	00 e0       	ldi	r16, 0x00	; 0
				LCD_Write_Command(LCD_CLEAR_CMD);
				LCD_Write_String("Welcome");
				break;
     88a:	95 cf       	rjmp	.-214    	; 0x7b6 <vTask_LCD+0x3a>
			}
		} 
		else
		{
			if (LCD_CurrentState != Welcome)
     88c:	11 23       	and	r17, r17
     88e:	09 f4       	brne	.+2      	; 0x892 <__stack+0x33>
     890:	92 cf       	rjmp	.-220    	; 0x7b6 <vTask_LCD+0x3a>
			{
				LCD_CurrentState = Welcome;
				passwordIndex=0;
				LCD_Write_Command(LCD_CLEAR_CMD);
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
				LCD_Write_String("Welcome");
     898:	86 e9       	ldi	r24, 0x96	; 150
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
		} 
		else
		{
			if (LCD_CurrentState != Welcome)
			{
				LCD_CurrentState = Welcome;
     8a0:	10 e0       	ldi	r17, 0x00	; 0
				passwordIndex=0;
     8a2:	00 e0       	ldi	r16, 0x00	; 0
     8a4:	88 cf       	rjmp	.-240    	; 0x7b6 <vTask_LCD+0x3a>

000008a6 <vTask_Password_Check>:
	}
}

void vTask_Password_Check(void  *vpParamter)
{
	xSemaphoreTake(CheckPasswordSemaphore,0);
     8a6:	20 e0       	ldi	r18, 0x00	; 0
     8a8:	40 e0       	ldi	r20, 0x00	; 0
     8aa:	50 e0       	ldi	r21, 0x00	; 0
     8ac:	60 e0       	ldi	r22, 0x00	; 0
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <CheckPasswordSemaphore>
     8b4:	90 91 de 04 	lds	r25, 0x04DE	; 0x8004de <CheckPasswordSemaphore+0x1>
     8b8:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <xQueueGenericReceive>
	LCD_Write_Command(LCD_CLEAR_CMD);
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
	LCD_Write_String("check");
     8c2:	88 ea       	ldi	r24, 0xA8	; 168
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
     8ca:	2f ef       	ldi	r18, 0xFF	; 255
     8cc:	89 e6       	ldi	r24, 0x69	; 105
     8ce:	98 e1       	ldi	r25, 0x18	; 24
     8d0:	21 50       	subi	r18, 0x01	; 1
     8d2:	80 40       	sbci	r24, 0x00	; 0
     8d4:	90 40       	sbci	r25, 0x00	; 0
     8d6:	e1 f7       	brne	.-8      	; 0x8d0 <vTask_Password_Check+0x2a>
     8d8:	00 c0       	rjmp	.+0      	; 0x8da <vTask_Password_Check+0x34>
     8da:	00 00       	nop
	_delay_ms(1000);
	while(1)
	{
		
	  // block on semaphore
	  xSemaphoreTake(CheckPasswordSemaphore,portMAX_DELAY);
     8dc:	20 e0       	ldi	r18, 0x00	; 0
     8de:	4f ef       	ldi	r20, 0xFF	; 255
     8e0:	5f ef       	ldi	r21, 0xFF	; 255
     8e2:	60 e0       	ldi	r22, 0x00	; 0
     8e4:	70 e0       	ldi	r23, 0x00	; 0
     8e6:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <CheckPasswordSemaphore>
     8ea:	90 91 de 04 	lds	r25, 0x04DE	; 0x8004de <CheckPasswordSemaphore+0x1>
     8ee:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <xQueueGenericReceive>
	  // check the password with saved password
	  if (strcmp(g_Password,g_CurrentPassword)==0)
     8f2:	62 e6       	ldi	r22, 0x62	; 98
     8f4:	70 e0       	ldi	r23, 0x00	; 0
     8f6:	83 ed       	ldi	r24, 0xD3	; 211
     8f8:	94 e0       	ldi	r25, 0x04	; 4
     8fa:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <strcmp>
     8fe:	89 2b       	or	r24, r25
     900:	41 f4       	brne	.+16     	; 0x912 <vTask_Password_Check+0x6c>
	  {
		LCD_Write_Command(LCD_CLEAR_CMD);
     902:	81 e0       	ldi	r24, 0x01	; 1
     904:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
		LCD_Write_String("Access granted");
     908:	8e ea       	ldi	r24, 0xAE	; 174
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
     910:	e5 cf       	rjmp	.-54     	; 0x8dc <vTask_Password_Check+0x36>
	  } 
	  else
	  {
		LCD_Write_Command(LCD_CLEAR_CMD);
     912:	81 e0       	ldi	r24, 0x01	; 1
     914:	0e 94 be 02 	call	0x57c	; 0x57c <LCD_Write_Command>
		LCD_Write_String("Access denied");
     918:	8d eb       	ldi	r24, 0xBD	; 189
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
     920:	dd cf       	rjmp	.-70     	; 0x8dc <vTask_Password_Check+0x36>

00000922 <main>:



int main()
{
	LCD_Initialization();
     922:	0e 94 e5 02 	call	0x5ca	; 0x5ca <LCD_Initialization>
	LCD_Write_String("hello");
     926:	8b ec       	ldi	r24, 0xCB	; 203
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	0e 94 d6 02 	call	0x5ac	; 0x5ac <LCD_Write_String>
	
	
	BaseType_t x=0;
		LCD_Queue = xQueueCreate(10,sizeof(char));
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	61 e0       	ldi	r22, 0x01	; 1
     932:	8a e0       	ldi	r24, 0x0A	; 10
     934:	0e 94 1a 08 	call	0x1034	; 0x1034 <xQueueGenericCreate>
     938:	90 93 e0 04 	sts	0x04E0, r25	; 0x8004e0 <LCD_Queue+0x1>
     93c:	80 93 df 04 	sts	0x04DF, r24	; 0x8004df <LCD_Queue>
		CheckPasswordSemaphore = xSemaphoreCreateBinary();
     940:	43 e0       	ldi	r20, 0x03	; 3
     942:	60 e0       	ldi	r22, 0x00	; 0
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	0e 94 1a 08 	call	0x1034	; 0x1034 <xQueueGenericCreate>
     94a:	90 93 de 04 	sts	0x04DE, r25	; 0x8004de <CheckPasswordSemaphore+0x1>
     94e:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <CheckPasswordSemaphore>
	
		
		x=xTaskCreate( vTask_LCD, "LCD",200,NULL, 1, NULL );
     952:	e1 2c       	mov	r14, r1
     954:	f1 2c       	mov	r15, r1
     956:	01 e0       	ldi	r16, 0x01	; 1
     958:	20 e0       	ldi	r18, 0x00	; 0
     95a:	30 e0       	ldi	r19, 0x00	; 0
     95c:	48 ec       	ldi	r20, 0xC8	; 200
     95e:	50 e0       	ldi	r21, 0x00	; 0
     960:	61 ed       	ldi	r22, 0xD1	; 209
     962:	70 e0       	ldi	r23, 0x00	; 0
     964:	8e eb       	ldi	r24, 0xBE	; 190
     966:	93 e0       	ldi	r25, 0x03	; 3
     968:	0e 94 2b 0a 	call	0x1456	; 0x1456 <xTaskCreate>
		
		x=xTaskCreate( vTask_KeyPad, "Keypad",200,NULL, 2, NULL );
     96c:	02 e0       	ldi	r16, 0x02	; 2
     96e:	20 e0       	ldi	r18, 0x00	; 0
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	48 ec       	ldi	r20, 0xC8	; 200
     974:	50 e0       	ldi	r21, 0x00	; 0
     976:	65 ed       	ldi	r22, 0xD5	; 213
     978:	70 e0       	ldi	r23, 0x00	; 0
     97a:	8c e8       	ldi	r24, 0x8C	; 140
     97c:	93 e0       	ldi	r25, 0x03	; 3
     97e:	0e 94 2b 0a 	call	0x1456	; 0x1456 <xTaskCreate>
		
		x=xTaskCreate( vTask_Password_Check, "check",200,NULL, 3, NULL );
     982:	03 e0       	ldi	r16, 0x03	; 3
     984:	20 e0       	ldi	r18, 0x00	; 0
     986:	30 e0       	ldi	r19, 0x00	; 0
     988:	48 ec       	ldi	r20, 0xC8	; 200
     98a:	50 e0       	ldi	r21, 0x00	; 0
     98c:	68 ea       	ldi	r22, 0xA8	; 168
     98e:	70 e0       	ldi	r23, 0x00	; 0
     990:	83 e5       	ldi	r24, 0x53	; 83
     992:	94 e0       	ldi	r25, 0x04	; 4
     994:	0e 94 2b 0a 	call	0x1456	; 0x1456 <xTaskCreate>
		
		
		
		
		vTaskStartScheduler();
     998:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vTaskStartScheduler>
	
	while(1);
     99c:	ff cf       	rjmp	.-2      	; 0x99c <main+0x7a>

0000099e <GPIO_Init>:
 #include "MCAL_GPIO.h"
 #include <avr/io.h>


 void GPIO_Init(GPIO_Init_Param_t * gpio_Param)
 {
     99e:	fc 01       	movw	r30, r24
	01001010  // direction
	00001111  // mask
	00001010

*/
	switch(gpio_Param->Port_Name)
     9a0:	80 81       	ld	r24, Z
     9a2:	81 30       	cpi	r24, 0x01	; 1
     9a4:	e1 f0       	breq	.+56     	; 0x9de <GPIO_Init+0x40>
     9a6:	30 f0       	brcs	.+12     	; 0x9b4 <GPIO_Init+0x16>
     9a8:	82 30       	cpi	r24, 0x02	; 2
     9aa:	71 f1       	breq	.+92     	; 0xa08 <GPIO_Init+0x6a>
     9ac:	83 30       	cpi	r24, 0x03	; 3
     9ae:	09 f4       	brne	.+2      	; 0x9b2 <GPIO_Init+0x14>
     9b0:	40 c0       	rjmp	.+128    	; 0xa32 <GPIO_Init+0x94>
     9b2:	08 95       	ret
	{
		case PT1:
			// Set the direction
			DDRA = (DDRA &~(gpio_Param->Mask)) | (gpio_Param->Direction&gpio_Param->Mask);
     9b4:	2a b3       	in	r18, 0x1a	; 26
     9b6:	81 81       	ldd	r24, Z+1	; 0x01
     9b8:	98 2f       	mov	r25, r24
     9ba:	90 95       	com	r25
     9bc:	29 23       	and	r18, r25
     9be:	92 81       	ldd	r25, Z+2	; 0x02
     9c0:	98 23       	and	r25, r24
     9c2:	82 2f       	mov	r24, r18
     9c4:	89 2b       	or	r24, r25
     9c6:	8a bb       	out	0x1a, r24	; 26
			PORTA = (PORTA &~(gpio_Param->Mask)) | (gpio_Param->IsPulledUp&gpio_Param->Mask);
     9c8:	2b b3       	in	r18, 0x1b	; 27
     9ca:	81 81       	ldd	r24, Z+1	; 0x01
     9cc:	98 2f       	mov	r25, r24
     9ce:	90 95       	com	r25
     9d0:	29 23       	and	r18, r25
     9d2:	93 81       	ldd	r25, Z+3	; 0x03
     9d4:	98 23       	and	r25, r24
     9d6:	82 2f       	mov	r24, r18
     9d8:	89 2b       	or	r24, r25
     9da:	8b bb       	out	0x1b, r24	; 27
		break;	
     9dc:	08 95       	ret
		case PT2:
		// Set the direction
		DDRB = (DDRB &~(gpio_Param->Mask)) | (gpio_Param->Direction&gpio_Param->Mask);
     9de:	27 b3       	in	r18, 0x17	; 23
     9e0:	81 81       	ldd	r24, Z+1	; 0x01
     9e2:	98 2f       	mov	r25, r24
     9e4:	90 95       	com	r25
     9e6:	29 23       	and	r18, r25
     9e8:	92 81       	ldd	r25, Z+2	; 0x02
     9ea:	98 23       	and	r25, r24
     9ec:	82 2f       	mov	r24, r18
     9ee:	89 2b       	or	r24, r25
     9f0:	87 bb       	out	0x17, r24	; 23
		PORTB = (PORTB &~(gpio_Param->Mask)) | (gpio_Param->IsPulledUp&gpio_Param->Mask);
     9f2:	28 b3       	in	r18, 0x18	; 24
     9f4:	81 81       	ldd	r24, Z+1	; 0x01
     9f6:	98 2f       	mov	r25, r24
     9f8:	90 95       	com	r25
     9fa:	29 23       	and	r18, r25
     9fc:	93 81       	ldd	r25, Z+3	; 0x03
     9fe:	98 23       	and	r25, r24
     a00:	82 2f       	mov	r24, r18
     a02:	89 2b       	or	r24, r25
     a04:	88 bb       	out	0x18, r24	; 24
		break;
     a06:	08 95       	ret
		case PT3:
		// Set the direction
		DDRC = (DDRC &~(gpio_Param->Mask)) | (gpio_Param->Direction&gpio_Param->Mask);
     a08:	24 b3       	in	r18, 0x14	; 20
     a0a:	81 81       	ldd	r24, Z+1	; 0x01
     a0c:	98 2f       	mov	r25, r24
     a0e:	90 95       	com	r25
     a10:	29 23       	and	r18, r25
     a12:	92 81       	ldd	r25, Z+2	; 0x02
     a14:	98 23       	and	r25, r24
     a16:	82 2f       	mov	r24, r18
     a18:	89 2b       	or	r24, r25
     a1a:	84 bb       	out	0x14, r24	; 20
		PORTC = (PORTC &~(gpio_Param->Mask)) | (gpio_Param->IsPulledUp&gpio_Param->Mask);
     a1c:	25 b3       	in	r18, 0x15	; 21
     a1e:	81 81       	ldd	r24, Z+1	; 0x01
     a20:	98 2f       	mov	r25, r24
     a22:	90 95       	com	r25
     a24:	29 23       	and	r18, r25
     a26:	93 81       	ldd	r25, Z+3	; 0x03
     a28:	98 23       	and	r25, r24
     a2a:	82 2f       	mov	r24, r18
     a2c:	89 2b       	or	r24, r25
     a2e:	85 bb       	out	0x15, r24	; 21
		break;
     a30:	08 95       	ret
		case PT4:
		// Set the direction
		DDRD = (DDRD &~(gpio_Param->Mask)) | (gpio_Param->Direction&gpio_Param->Mask);
     a32:	21 b3       	in	r18, 0x11	; 17
     a34:	81 81       	ldd	r24, Z+1	; 0x01
     a36:	98 2f       	mov	r25, r24
     a38:	90 95       	com	r25
     a3a:	29 23       	and	r18, r25
     a3c:	92 81       	ldd	r25, Z+2	; 0x02
     a3e:	98 23       	and	r25, r24
     a40:	82 2f       	mov	r24, r18
     a42:	89 2b       	or	r24, r25
     a44:	81 bb       	out	0x11, r24	; 17
		PORTD = (PORTD &~(gpio_Param->Mask)) | (gpio_Param->IsPulledUp&gpio_Param->Mask);
     a46:	22 b3       	in	r18, 0x12	; 18
     a48:	81 81       	ldd	r24, Z+1	; 0x01
     a4a:	98 2f       	mov	r25, r24
     a4c:	90 95       	com	r25
     a4e:	29 23       	and	r18, r25
     a50:	93 81       	ldd	r25, Z+3	; 0x03
     a52:	98 23       	and	r25, r24
     a54:	82 2f       	mov	r24, r18
     a56:	89 2b       	or	r24, r25
     a58:	82 bb       	out	0x12, r24	; 18
     a5a:	08 95       	ret

00000a5c <GPIO_Write>:
		
	}
 }

 void GPIO_Write(GPIO_Write_Param_t * gpio_Param)
 {
     a5c:	fc 01       	movw	r30, r24
 switch(gpio_Param->Port_Name)
     a5e:	90 81       	ld	r25, Z
     a60:	91 30       	cpi	r25, 0x01	; 1
     a62:	89 f0       	breq	.+34     	; 0xa86 <GPIO_Write+0x2a>
     a64:	28 f0       	brcs	.+10     	; 0xa70 <GPIO_Write+0x14>
     a66:	92 30       	cpi	r25, 0x02	; 2
     a68:	c9 f0       	breq	.+50     	; 0xa9c <GPIO_Write+0x40>
     a6a:	93 30       	cpi	r25, 0x03	; 3
     a6c:	11 f1       	breq	.+68     	; 0xab2 <GPIO_Write+0x56>
     a6e:	08 95       	ret
 {
	 case PT1:
	 // Set the direction
	 PORTA = (PORTA &~(gpio_Param->Mask)) | (gpio_Param->Data&gpio_Param->Mask);
     a70:	2b b3       	in	r18, 0x1b	; 27
     a72:	81 81       	ldd	r24, Z+1	; 0x01
     a74:	98 2f       	mov	r25, r24
     a76:	90 95       	com	r25
     a78:	29 23       	and	r18, r25
     a7a:	92 81       	ldd	r25, Z+2	; 0x02
     a7c:	98 23       	and	r25, r24
     a7e:	82 2f       	mov	r24, r18
     a80:	89 2b       	or	r24, r25
     a82:	8b bb       	out	0x1b, r24	; 27
	 break;
     a84:	08 95       	ret
	 case PT2:
	 // Set the direction
	 PORTB = (PORTB &~(gpio_Param->Mask)) | (gpio_Param->Data&gpio_Param->Mask);
     a86:	28 b3       	in	r18, 0x18	; 24
     a88:	81 81       	ldd	r24, Z+1	; 0x01
     a8a:	98 2f       	mov	r25, r24
     a8c:	90 95       	com	r25
     a8e:	29 23       	and	r18, r25
     a90:	92 81       	ldd	r25, Z+2	; 0x02
     a92:	98 23       	and	r25, r24
     a94:	82 2f       	mov	r24, r18
     a96:	89 2b       	or	r24, r25
     a98:	88 bb       	out	0x18, r24	; 24
	 break;
     a9a:	08 95       	ret
	 case PT3:
	 // Set the direction
	 PORTC = (PORTC &~(gpio_Param->Mask)) | (gpio_Param->Data&gpio_Param->Mask);
     a9c:	25 b3       	in	r18, 0x15	; 21
     a9e:	81 81       	ldd	r24, Z+1	; 0x01
     aa0:	98 2f       	mov	r25, r24
     aa2:	90 95       	com	r25
     aa4:	29 23       	and	r18, r25
     aa6:	92 81       	ldd	r25, Z+2	; 0x02
     aa8:	98 23       	and	r25, r24
     aaa:	82 2f       	mov	r24, r18
     aac:	89 2b       	or	r24, r25
     aae:	85 bb       	out	0x15, r24	; 21
	 break;
     ab0:	08 95       	ret
	 case PT4:
	 // Set the direction
	 PORTD = (PORTD &~(gpio_Param->Mask)) | (gpio_Param->Data&gpio_Param->Mask);
     ab2:	22 b3       	in	r18, 0x12	; 18
     ab4:	81 81       	ldd	r24, Z+1	; 0x01
     ab6:	98 2f       	mov	r25, r24
     ab8:	90 95       	com	r25
     aba:	29 23       	and	r18, r25
     abc:	92 81       	ldd	r25, Z+2	; 0x02
     abe:	98 23       	and	r25, r24
     ac0:	82 2f       	mov	r24, r18
     ac2:	89 2b       	or	r24, r25
     ac4:	82 bb       	out	0x12, r24	; 18
     ac6:	08 95       	ret

00000ac8 <GPIO_Read>:
	 break;
	 
 }
 }
 uint8_t GPIO_Read(GPIO_Read_Param_t * gpio_Param)
 {
     ac8:	fc 01       	movw	r30, r24
	uint8_t value = 0;
	switch(gpio_Param->Port_Name)
     aca:	90 81       	ld	r25, Z
     acc:	91 30       	cpi	r25, 0x01	; 1
     ace:	c9 f0       	breq	.+50     	; 0xb02 <GPIO_Read+0x3a>
     ad0:	28 f0       	brcs	.+10     	; 0xadc <GPIO_Read+0x14>
     ad2:	92 30       	cpi	r25, 0x02	; 2
     ad4:	49 f1       	breq	.+82     	; 0xb28 <GPIO_Read+0x60>
     ad6:	93 30       	cpi	r25, 0x03	; 3
     ad8:	d1 f1       	breq	.+116    	; 0xb4e <GPIO_Read+0x86>
     ada:	4c c0       	rjmp	.+152    	; 0xb74 <GPIO_Read+0xac>
	{
		case PT1:
		value = (uint8_t)((PINA & (1U<<(gpio_Param->PIN_Number)))>>gpio_Param->PIN_Number);
     adc:	29 b3       	in	r18, 0x19	; 25
     ade:	41 81       	ldd	r20, Z+1	; 0x01
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	04 2e       	mov	r0, r20
     ae6:	02 c0       	rjmp	.+4      	; 0xaec <GPIO_Read+0x24>
     ae8:	88 0f       	add	r24, r24
     aea:	99 1f       	adc	r25, r25
     aec:	0a 94       	dec	r0
     aee:	e2 f7       	brpl	.-8      	; 0xae8 <GPIO_Read+0x20>
     af0:	30 e0       	ldi	r19, 0x00	; 0
     af2:	82 23       	and	r24, r18
     af4:	93 23       	and	r25, r19
     af6:	02 c0       	rjmp	.+4      	; 0xafc <GPIO_Read+0x34>
     af8:	96 95       	lsr	r25
     afa:	87 95       	ror	r24
     afc:	4a 95       	dec	r20
     afe:	e2 f7       	brpl	.-8      	; 0xaf8 <GPIO_Read+0x30>
		break;
     b00:	08 95       	ret
		case PT2:
		value = (uint8_t)((PINB & (1U<<(gpio_Param->PIN_Number)))>>gpio_Param->PIN_Number);
     b02:	26 b3       	in	r18, 0x16	; 22
     b04:	41 81       	ldd	r20, Z+1	; 0x01
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	04 2e       	mov	r0, r20
     b0c:	02 c0       	rjmp	.+4      	; 0xb12 <GPIO_Read+0x4a>
     b0e:	88 0f       	add	r24, r24
     b10:	99 1f       	adc	r25, r25
     b12:	0a 94       	dec	r0
     b14:	e2 f7       	brpl	.-8      	; 0xb0e <GPIO_Read+0x46>
     b16:	30 e0       	ldi	r19, 0x00	; 0
     b18:	82 23       	and	r24, r18
     b1a:	93 23       	and	r25, r19
     b1c:	02 c0       	rjmp	.+4      	; 0xb22 <GPIO_Read+0x5a>
     b1e:	96 95       	lsr	r25
     b20:	87 95       	ror	r24
     b22:	4a 95       	dec	r20
     b24:	e2 f7       	brpl	.-8      	; 0xb1e <GPIO_Read+0x56>
		break;
     b26:	08 95       	ret
		case PT3:
		value = (uint8_t)((PINC & (1U<<(gpio_Param->PIN_Number)))>>gpio_Param->PIN_Number);
     b28:	23 b3       	in	r18, 0x13	; 19
     b2a:	41 81       	ldd	r20, Z+1	; 0x01
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	04 2e       	mov	r0, r20
     b32:	02 c0       	rjmp	.+4      	; 0xb38 <GPIO_Read+0x70>
     b34:	88 0f       	add	r24, r24
     b36:	99 1f       	adc	r25, r25
     b38:	0a 94       	dec	r0
     b3a:	e2 f7       	brpl	.-8      	; 0xb34 <GPIO_Read+0x6c>
     b3c:	30 e0       	ldi	r19, 0x00	; 0
     b3e:	82 23       	and	r24, r18
     b40:	93 23       	and	r25, r19
     b42:	02 c0       	rjmp	.+4      	; 0xb48 <GPIO_Read+0x80>
     b44:	96 95       	lsr	r25
     b46:	87 95       	ror	r24
     b48:	4a 95       	dec	r20
     b4a:	e2 f7       	brpl	.-8      	; 0xb44 <GPIO_Read+0x7c>
		break;
     b4c:	08 95       	ret
		case PT4:
		value = (uint8_t)((PIND & (1U<<(gpio_Param->PIN_Number)))>>gpio_Param->PIN_Number);
     b4e:	20 b3       	in	r18, 0x10	; 16
     b50:	41 81       	ldd	r20, Z+1	; 0x01
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	04 2e       	mov	r0, r20
     b58:	02 c0       	rjmp	.+4      	; 0xb5e <GPIO_Read+0x96>
     b5a:	88 0f       	add	r24, r24
     b5c:	99 1f       	adc	r25, r25
     b5e:	0a 94       	dec	r0
     b60:	e2 f7       	brpl	.-8      	; 0xb5a <GPIO_Read+0x92>
     b62:	30 e0       	ldi	r19, 0x00	; 0
     b64:	82 23       	and	r24, r18
     b66:	93 23       	and	r25, r19
     b68:	02 c0       	rjmp	.+4      	; 0xb6e <GPIO_Read+0xa6>
     b6a:	96 95       	lsr	r25
     b6c:	87 95       	ror	r24
     b6e:	4a 95       	dec	r20
     b70:	e2 f7       	brpl	.-8      	; 0xb6a <GPIO_Read+0xa2>
		break;
     b72:	08 95       	ret
	 
 }
 }
 uint8_t GPIO_Read(GPIO_Read_Param_t * gpio_Param)
 {
	uint8_t value = 0;
     b74:	80 e0       	ldi	r24, 0x00	; 0
		/* nothing changed =>> MISRA rule */
		break;
		
	}
	return value;
     b76:	08 95       	ret

00000b78 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b78:	31 e1       	ldi	r19, 0x11	; 17
     b7a:	fc 01       	movw	r30, r24
     b7c:	30 83       	st	Z, r19
     b7e:	31 97       	sbiw	r30, 0x01	; 1
     b80:	22 e2       	ldi	r18, 0x22	; 34
     b82:	20 83       	st	Z, r18
     b84:	31 97       	sbiw	r30, 0x01	; 1
     b86:	a3 e3       	ldi	r26, 0x33	; 51
     b88:	a0 83       	st	Z, r26
     b8a:	31 97       	sbiw	r30, 0x01	; 1
     b8c:	60 83       	st	Z, r22
     b8e:	31 97       	sbiw	r30, 0x01	; 1
     b90:	70 83       	st	Z, r23
     b92:	31 97       	sbiw	r30, 0x01	; 1
     b94:	10 82       	st	Z, r1
     b96:	31 97       	sbiw	r30, 0x01	; 1
     b98:	60 e8       	ldi	r22, 0x80	; 128
     b9a:	60 83       	st	Z, r22
     b9c:	31 97       	sbiw	r30, 0x01	; 1
     b9e:	10 82       	st	Z, r1
     ba0:	31 97       	sbiw	r30, 0x01	; 1
     ba2:	62 e0       	ldi	r22, 0x02	; 2
     ba4:	60 83       	st	Z, r22
     ba6:	31 97       	sbiw	r30, 0x01	; 1
     ba8:	63 e0       	ldi	r22, 0x03	; 3
     baa:	60 83       	st	Z, r22
     bac:	31 97       	sbiw	r30, 0x01	; 1
     bae:	64 e0       	ldi	r22, 0x04	; 4
     bb0:	60 83       	st	Z, r22
     bb2:	31 97       	sbiw	r30, 0x01	; 1
     bb4:	65 e0       	ldi	r22, 0x05	; 5
     bb6:	60 83       	st	Z, r22
     bb8:	31 97       	sbiw	r30, 0x01	; 1
     bba:	66 e0       	ldi	r22, 0x06	; 6
     bbc:	60 83       	st	Z, r22
     bbe:	31 97       	sbiw	r30, 0x01	; 1
     bc0:	67 e0       	ldi	r22, 0x07	; 7
     bc2:	60 83       	st	Z, r22
     bc4:	31 97       	sbiw	r30, 0x01	; 1
     bc6:	68 e0       	ldi	r22, 0x08	; 8
     bc8:	60 83       	st	Z, r22
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	69 e0       	ldi	r22, 0x09	; 9
     bce:	60 83       	st	Z, r22
     bd0:	31 97       	sbiw	r30, 0x01	; 1
     bd2:	60 e1       	ldi	r22, 0x10	; 16
     bd4:	60 83       	st	Z, r22
     bd6:	31 97       	sbiw	r30, 0x01	; 1
     bd8:	30 83       	st	Z, r19
     bda:	31 97       	sbiw	r30, 0x01	; 1
     bdc:	32 e1       	ldi	r19, 0x12	; 18
     bde:	30 83       	st	Z, r19
     be0:	31 97       	sbiw	r30, 0x01	; 1
     be2:	33 e1       	ldi	r19, 0x13	; 19
     be4:	30 83       	st	Z, r19
     be6:	31 97       	sbiw	r30, 0x01	; 1
     be8:	34 e1       	ldi	r19, 0x14	; 20
     bea:	30 83       	st	Z, r19
     bec:	31 97       	sbiw	r30, 0x01	; 1
     bee:	35 e1       	ldi	r19, 0x15	; 21
     bf0:	30 83       	st	Z, r19
     bf2:	31 97       	sbiw	r30, 0x01	; 1
     bf4:	36 e1       	ldi	r19, 0x16	; 22
     bf6:	30 83       	st	Z, r19
     bf8:	31 97       	sbiw	r30, 0x01	; 1
     bfa:	37 e1       	ldi	r19, 0x17	; 23
     bfc:	30 83       	st	Z, r19
     bfe:	31 97       	sbiw	r30, 0x01	; 1
     c00:	38 e1       	ldi	r19, 0x18	; 24
     c02:	30 83       	st	Z, r19
     c04:	31 97       	sbiw	r30, 0x01	; 1
     c06:	39 e1       	ldi	r19, 0x19	; 25
     c08:	30 83       	st	Z, r19
     c0a:	31 97       	sbiw	r30, 0x01	; 1
     c0c:	30 e2       	ldi	r19, 0x20	; 32
     c0e:	30 83       	st	Z, r19
     c10:	31 97       	sbiw	r30, 0x01	; 1
     c12:	31 e2       	ldi	r19, 0x21	; 33
     c14:	30 83       	st	Z, r19
     c16:	31 97       	sbiw	r30, 0x01	; 1
     c18:	20 83       	st	Z, r18
     c1a:	31 97       	sbiw	r30, 0x01	; 1
     c1c:	23 e2       	ldi	r18, 0x23	; 35
     c1e:	20 83       	st	Z, r18
     c20:	31 97       	sbiw	r30, 0x01	; 1
     c22:	40 83       	st	Z, r20
     c24:	31 97       	sbiw	r30, 0x01	; 1
     c26:	50 83       	st	Z, r21
     c28:	31 97       	sbiw	r30, 0x01	; 1
     c2a:	26 e2       	ldi	r18, 0x26	; 38
     c2c:	20 83       	st	Z, r18
     c2e:	31 97       	sbiw	r30, 0x01	; 1
     c30:	27 e2       	ldi	r18, 0x27	; 39
     c32:	20 83       	st	Z, r18
     c34:	31 97       	sbiw	r30, 0x01	; 1
     c36:	28 e2       	ldi	r18, 0x28	; 40
     c38:	20 83       	st	Z, r18
     c3a:	31 97       	sbiw	r30, 0x01	; 1
     c3c:	29 e2       	ldi	r18, 0x29	; 41
     c3e:	20 83       	st	Z, r18
     c40:	31 97       	sbiw	r30, 0x01	; 1
     c42:	20 e3       	ldi	r18, 0x30	; 48
     c44:	20 83       	st	Z, r18
     c46:	31 97       	sbiw	r30, 0x01	; 1
     c48:	21 e3       	ldi	r18, 0x31	; 49
     c4a:	20 83       	st	Z, r18
     c4c:	86 97       	sbiw	r24, 0x26	; 38
     c4e:	08 95       	ret

00000c50 <xPortStartScheduler>:
     c50:	1b bc       	out	0x2b, r1	; 43
     c52:	8c e7       	ldi	r24, 0x7C	; 124
     c54:	8a bd       	out	0x2a, r24	; 42
     c56:	8b e0       	ldi	r24, 0x0B	; 11
     c58:	8e bd       	out	0x2e, r24	; 46
     c5a:	89 b7       	in	r24, 0x39	; 57
     c5c:	80 61       	ori	r24, 0x10	; 16
     c5e:	89 bf       	out	0x39, r24	; 57
     c60:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
     c64:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
     c68:	cd 91       	ld	r28, X+
     c6a:	cd bf       	out	0x3d, r28	; 61
     c6c:	dd 91       	ld	r29, X+
     c6e:	de bf       	out	0x3e, r29	; 62
     c70:	ff 91       	pop	r31
     c72:	ef 91       	pop	r30
     c74:	df 91       	pop	r29
     c76:	cf 91       	pop	r28
     c78:	bf 91       	pop	r27
     c7a:	af 91       	pop	r26
     c7c:	9f 91       	pop	r25
     c7e:	8f 91       	pop	r24
     c80:	7f 91       	pop	r23
     c82:	6f 91       	pop	r22
     c84:	5f 91       	pop	r21
     c86:	4f 91       	pop	r20
     c88:	3f 91       	pop	r19
     c8a:	2f 91       	pop	r18
     c8c:	1f 91       	pop	r17
     c8e:	0f 91       	pop	r16
     c90:	ff 90       	pop	r15
     c92:	ef 90       	pop	r14
     c94:	df 90       	pop	r13
     c96:	cf 90       	pop	r12
     c98:	bf 90       	pop	r11
     c9a:	af 90       	pop	r10
     c9c:	9f 90       	pop	r9
     c9e:	8f 90       	pop	r8
     ca0:	7f 90       	pop	r7
     ca2:	6f 90       	pop	r6
     ca4:	5f 90       	pop	r5
     ca6:	4f 90       	pop	r4
     ca8:	3f 90       	pop	r3
     caa:	2f 90       	pop	r2
     cac:	1f 90       	pop	r1
     cae:	0f 90       	pop	r0
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	0f 90       	pop	r0
     cb4:	08 95       	ret
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	08 95       	ret

00000cba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     cba:	0f 92       	push	r0
     cbc:	0f b6       	in	r0, 0x3f	; 63
     cbe:	f8 94       	cli
     cc0:	0f 92       	push	r0
     cc2:	1f 92       	push	r1
     cc4:	11 24       	eor	r1, r1
     cc6:	2f 92       	push	r2
     cc8:	3f 92       	push	r3
     cca:	4f 92       	push	r4
     ccc:	5f 92       	push	r5
     cce:	6f 92       	push	r6
     cd0:	7f 92       	push	r7
     cd2:	8f 92       	push	r8
     cd4:	9f 92       	push	r9
     cd6:	af 92       	push	r10
     cd8:	bf 92       	push	r11
     cda:	cf 92       	push	r12
     cdc:	df 92       	push	r13
     cde:	ef 92       	push	r14
     ce0:	ff 92       	push	r15
     ce2:	0f 93       	push	r16
     ce4:	1f 93       	push	r17
     ce6:	2f 93       	push	r18
     ce8:	3f 93       	push	r19
     cea:	4f 93       	push	r20
     cec:	5f 93       	push	r21
     cee:	6f 93       	push	r22
     cf0:	7f 93       	push	r23
     cf2:	8f 93       	push	r24
     cf4:	9f 93       	push	r25
     cf6:	af 93       	push	r26
     cf8:	bf 93       	push	r27
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	ef 93       	push	r30
     d00:	ff 93       	push	r31
     d02:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
     d06:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
     d0a:	0d b6       	in	r0, 0x3d	; 61
     d0c:	0d 92       	st	X+, r0
     d0e:	0e b6       	in	r0, 0x3e	; 62
     d10:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d12:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d16:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
     d1a:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
     d1e:	cd 91       	ld	r28, X+
     d20:	cd bf       	out	0x3d, r28	; 61
     d22:	dd 91       	ld	r29, X+
     d24:	de bf       	out	0x3e, r29	; 62
     d26:	ff 91       	pop	r31
     d28:	ef 91       	pop	r30
     d2a:	df 91       	pop	r29
     d2c:	cf 91       	pop	r28
     d2e:	bf 91       	pop	r27
     d30:	af 91       	pop	r26
     d32:	9f 91       	pop	r25
     d34:	8f 91       	pop	r24
     d36:	7f 91       	pop	r23
     d38:	6f 91       	pop	r22
     d3a:	5f 91       	pop	r21
     d3c:	4f 91       	pop	r20
     d3e:	3f 91       	pop	r19
     d40:	2f 91       	pop	r18
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	df 90       	pop	r13
     d4c:	cf 90       	pop	r12
     d4e:	bf 90       	pop	r11
     d50:	af 90       	pop	r10
     d52:	9f 90       	pop	r9
     d54:	8f 90       	pop	r8
     d56:	7f 90       	pop	r7
     d58:	6f 90       	pop	r6
     d5a:	5f 90       	pop	r5
     d5c:	4f 90       	pop	r4
     d5e:	3f 90       	pop	r3
     d60:	2f 90       	pop	r2
     d62:	1f 90       	pop	r1
     d64:	0f 90       	pop	r0
     d66:	0f be       	out	0x3f, r0	; 63
     d68:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d6a:	08 95       	ret

00000d6c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d6c:	0f 92       	push	r0
     d6e:	0f b6       	in	r0, 0x3f	; 63
     d70:	f8 94       	cli
     d72:	0f 92       	push	r0
     d74:	1f 92       	push	r1
     d76:	11 24       	eor	r1, r1
     d78:	2f 92       	push	r2
     d7a:	3f 92       	push	r3
     d7c:	4f 92       	push	r4
     d7e:	5f 92       	push	r5
     d80:	6f 92       	push	r6
     d82:	7f 92       	push	r7
     d84:	8f 92       	push	r8
     d86:	9f 92       	push	r9
     d88:	af 92       	push	r10
     d8a:	bf 92       	push	r11
     d8c:	cf 92       	push	r12
     d8e:	df 92       	push	r13
     d90:	ef 92       	push	r14
     d92:	ff 92       	push	r15
     d94:	0f 93       	push	r16
     d96:	1f 93       	push	r17
     d98:	2f 93       	push	r18
     d9a:	3f 93       	push	r19
     d9c:	4f 93       	push	r20
     d9e:	5f 93       	push	r21
     da0:	6f 93       	push	r22
     da2:	7f 93       	push	r23
     da4:	8f 93       	push	r24
     da6:	9f 93       	push	r25
     da8:	af 93       	push	r26
     daa:	bf 93       	push	r27
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	ef 93       	push	r30
     db2:	ff 93       	push	r31
     db4:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
     db8:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
     dbc:	0d b6       	in	r0, 0x3d	; 61
     dbe:	0d 92       	st	X+, r0
     dc0:	0e b6       	in	r0, 0x3e	; 62
     dc2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     dc4:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <xTaskIncrementTick>
     dc8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     dca:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     dce:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
     dd2:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
     dd6:	cd 91       	ld	r28, X+
     dd8:	cd bf       	out	0x3d, r28	; 61
     dda:	dd 91       	ld	r29, X+
     ddc:	de bf       	out	0x3e, r29	; 62
     dde:	ff 91       	pop	r31
     de0:	ef 91       	pop	r30
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	bf 91       	pop	r27
     de8:	af 91       	pop	r26
     dea:	9f 91       	pop	r25
     dec:	8f 91       	pop	r24
     dee:	7f 91       	pop	r23
     df0:	6f 91       	pop	r22
     df2:	5f 91       	pop	r21
     df4:	4f 91       	pop	r20
     df6:	3f 91       	pop	r19
     df8:	2f 91       	pop	r18
     dfa:	1f 91       	pop	r17
     dfc:	0f 91       	pop	r16
     dfe:	ff 90       	pop	r15
     e00:	ef 90       	pop	r14
     e02:	df 90       	pop	r13
     e04:	cf 90       	pop	r12
     e06:	bf 90       	pop	r11
     e08:	af 90       	pop	r10
     e0a:	9f 90       	pop	r9
     e0c:	8f 90       	pop	r8
     e0e:	7f 90       	pop	r7
     e10:	6f 90       	pop	r6
     e12:	5f 90       	pop	r5
     e14:	4f 90       	pop	r4
     e16:	3f 90       	pop	r3
     e18:	2f 90       	pop	r2
     e1a:	1f 90       	pop	r1
     e1c:	0f 90       	pop	r0
     e1e:	0f be       	out	0x3f, r0	; 63
     e20:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e22:	08 95       	ret

00000e24 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     e24:	0e 94 b6 06 	call	0xd6c	; 0xd6c <vPortYieldFromTick>
		asm volatile ( "reti" );
     e28:	18 95       	reti

00000e2a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
     e30:	df 93       	push	r29
     e32:	ec 01       	movw	r28, r24
     e34:	04 2f       	mov	r16, r20
     e36:	1a 8d       	ldd	r17, Y+26	; 0x1a
     e38:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e3a:	81 11       	cpse	r24, r1
     e3c:	0c c0       	rjmp	.+24     	; 0xe56 <prvCopyDataToQueue+0x2c>
     e3e:	88 81       	ld	r24, Y
     e40:	99 81       	ldd	r25, Y+1	; 0x01
     e42:	89 2b       	or	r24, r25
     e44:	09 f0       	breq	.+2      	; 0xe48 <prvCopyDataToQueue+0x1e>
     e46:	44 c0       	rjmp	.+136    	; 0xed0 <prvCopyDataToQueue+0xa6>
     e48:	8a 81       	ldd	r24, Y+2	; 0x02
     e4a:	9b 81       	ldd	r25, Y+3	; 0x03
     e4c:	0e 94 62 0e 	call	0x1cc4	; 0x1cc4 <xTaskPriorityDisinherit>
     e50:	1b 82       	std	Y+3, r1	; 0x03
     e52:	1a 82       	std	Y+2, r1	; 0x02
     e54:	44 c0       	rjmp	.+136    	; 0xede <prvCopyDataToQueue+0xb4>
     e56:	41 11       	cpse	r20, r1
     e58:	18 c0       	rjmp	.+48     	; 0xe8a <prvCopyDataToQueue+0x60>
     e5a:	48 2f       	mov	r20, r24
     e5c:	50 e0       	ldi	r21, 0x00	; 0
     e5e:	8c 81       	ldd	r24, Y+4	; 0x04
     e60:	9d 81       	ldd	r25, Y+5	; 0x05
     e62:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <memcpy>
     e66:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e68:	8c 81       	ldd	r24, Y+4	; 0x04
     e6a:	9d 81       	ldd	r25, Y+5	; 0x05
     e6c:	82 0f       	add	r24, r18
     e6e:	91 1d       	adc	r25, r1
     e70:	9d 83       	std	Y+5, r25	; 0x05
     e72:	8c 83       	std	Y+4, r24	; 0x04
     e74:	2a 81       	ldd	r18, Y+2	; 0x02
     e76:	3b 81       	ldd	r19, Y+3	; 0x03
     e78:	82 17       	cp	r24, r18
     e7a:	93 07       	cpc	r25, r19
     e7c:	58 f1       	brcs	.+86     	; 0xed4 <prvCopyDataToQueue+0xaa>
     e7e:	88 81       	ld	r24, Y
     e80:	99 81       	ldd	r25, Y+1	; 0x01
     e82:	9d 83       	std	Y+5, r25	; 0x05
     e84:	8c 83       	std	Y+4, r24	; 0x04
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	2a c0       	rjmp	.+84     	; 0xede <prvCopyDataToQueue+0xb4>
     e8a:	48 2f       	mov	r20, r24
     e8c:	50 e0       	ldi	r21, 0x00	; 0
     e8e:	8e 81       	ldd	r24, Y+6	; 0x06
     e90:	9f 81       	ldd	r25, Y+7	; 0x07
     e92:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <memcpy>
     e96:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	91 95       	neg	r25
     e9c:	81 95       	neg	r24
     e9e:	91 09       	sbc	r25, r1
     ea0:	2e 81       	ldd	r18, Y+6	; 0x06
     ea2:	3f 81       	ldd	r19, Y+7	; 0x07
     ea4:	28 0f       	add	r18, r24
     ea6:	39 1f       	adc	r19, r25
     ea8:	3f 83       	std	Y+7, r19	; 0x07
     eaa:	2e 83       	std	Y+6, r18	; 0x06
     eac:	48 81       	ld	r20, Y
     eae:	59 81       	ldd	r21, Y+1	; 0x01
     eb0:	24 17       	cp	r18, r20
     eb2:	35 07       	cpc	r19, r21
     eb4:	30 f4       	brcc	.+12     	; 0xec2 <prvCopyDataToQueue+0x98>
     eb6:	2a 81       	ldd	r18, Y+2	; 0x02
     eb8:	3b 81       	ldd	r19, Y+3	; 0x03
     eba:	82 0f       	add	r24, r18
     ebc:	93 1f       	adc	r25, r19
     ebe:	9f 83       	std	Y+7, r25	; 0x07
     ec0:	8e 83       	std	Y+6, r24	; 0x06
     ec2:	02 30       	cpi	r16, 0x02	; 2
     ec4:	49 f4       	brne	.+18     	; 0xed8 <prvCopyDataToQueue+0xae>
     ec6:	11 23       	and	r17, r17
     ec8:	49 f0       	breq	.+18     	; 0xedc <prvCopyDataToQueue+0xb2>
     eca:	11 50       	subi	r17, 0x01	; 1
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	07 c0       	rjmp	.+14     	; 0xede <prvCopyDataToQueue+0xb4>
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	05 c0       	rjmp	.+10     	; 0xede <prvCopyDataToQueue+0xb4>
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	03 c0       	rjmp	.+6      	; 0xede <prvCopyDataToQueue+0xb4>
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	01 c0       	rjmp	.+2      	; 0xede <prvCopyDataToQueue+0xb4>
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	1f 5f       	subi	r17, 0xFF	; 255
     ee0:	1a 8f       	std	Y+26, r17	; 0x1a
     ee2:	df 91       	pop	r29
     ee4:	cf 91       	pop	r28
     ee6:	1f 91       	pop	r17
     ee8:	0f 91       	pop	r16
     eea:	08 95       	ret

00000eec <prvCopyDataFromQueue>:
     eec:	fc 01       	movw	r30, r24
     eee:	44 8d       	ldd	r20, Z+28	; 0x1c
     ef0:	44 23       	and	r20, r20
     ef2:	a9 f0       	breq	.+42     	; 0xf1e <prvCopyDataFromQueue+0x32>
     ef4:	50 e0       	ldi	r21, 0x00	; 0
     ef6:	26 81       	ldd	r18, Z+6	; 0x06
     ef8:	37 81       	ldd	r19, Z+7	; 0x07
     efa:	24 0f       	add	r18, r20
     efc:	35 1f       	adc	r19, r21
     efe:	37 83       	std	Z+7, r19	; 0x07
     f00:	26 83       	std	Z+6, r18	; 0x06
     f02:	82 81       	ldd	r24, Z+2	; 0x02
     f04:	93 81       	ldd	r25, Z+3	; 0x03
     f06:	28 17       	cp	r18, r24
     f08:	39 07       	cpc	r19, r25
     f0a:	20 f0       	brcs	.+8      	; 0xf14 <prvCopyDataFromQueue+0x28>
     f0c:	80 81       	ld	r24, Z
     f0e:	91 81       	ldd	r25, Z+1	; 0x01
     f10:	97 83       	std	Z+7, r25	; 0x07
     f12:	86 83       	std	Z+6, r24	; 0x06
     f14:	cb 01       	movw	r24, r22
     f16:	66 81       	ldd	r22, Z+6	; 0x06
     f18:	77 81       	ldd	r23, Z+7	; 0x07
     f1a:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <memcpy>
     f1e:	08 95       	ret

00000f20 <prvUnlockQueue>:
     f20:	ef 92       	push	r14
     f22:	ff 92       	push	r15
     f24:	0f 93       	push	r16
     f26:	1f 93       	push	r17
     f28:	cf 93       	push	r28
     f2a:	8c 01       	movw	r16, r24
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	0f 92       	push	r0
     f32:	fc 01       	movw	r30, r24
     f34:	c6 8d       	ldd	r28, Z+30	; 0x1e
     f36:	1c 16       	cp	r1, r28
     f38:	ac f4       	brge	.+42     	; 0xf64 <prvUnlockQueue+0x44>
     f3a:	81 89       	ldd	r24, Z+17	; 0x11
     f3c:	81 11       	cpse	r24, r1
     f3e:	06 c0       	rjmp	.+12     	; 0xf4c <prvUnlockQueue+0x2c>
     f40:	11 c0       	rjmp	.+34     	; 0xf64 <prvUnlockQueue+0x44>
     f42:	f8 01       	movw	r30, r16
     f44:	91 89       	ldd	r25, Z+17	; 0x11
     f46:	91 11       	cpse	r25, r1
     f48:	05 c0       	rjmp	.+10     	; 0xf54 <prvUnlockQueue+0x34>
     f4a:	0c c0       	rjmp	.+24     	; 0xf64 <prvUnlockQueue+0x44>
     f4c:	78 01       	movw	r14, r16
     f4e:	f1 e1       	ldi	r31, 0x11	; 17
     f50:	ef 0e       	add	r14, r31
     f52:	f1 1c       	adc	r15, r1
     f54:	c7 01       	movw	r24, r14
     f56:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
     f5a:	81 11       	cpse	r24, r1
     f5c:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <vTaskMissedYield>
     f60:	c1 50       	subi	r28, 0x01	; 1
     f62:	79 f7       	brne	.-34     	; 0xf42 <prvUnlockQueue+0x22>
     f64:	8f ef       	ldi	r24, 0xFF	; 255
     f66:	f8 01       	movw	r30, r16
     f68:	86 8f       	std	Z+30, r24	; 0x1e
     f6a:	0f 90       	pop	r0
     f6c:	0f be       	out	0x3f, r0	; 63
     f6e:	0f b6       	in	r0, 0x3f	; 63
     f70:	f8 94       	cli
     f72:	0f 92       	push	r0
     f74:	c5 8d       	ldd	r28, Z+29	; 0x1d
     f76:	1c 16       	cp	r1, r28
     f78:	ac f4       	brge	.+42     	; 0xfa4 <prvUnlockQueue+0x84>
     f7a:	80 85       	ldd	r24, Z+8	; 0x08
     f7c:	81 11       	cpse	r24, r1
     f7e:	06 c0       	rjmp	.+12     	; 0xf8c <prvUnlockQueue+0x6c>
     f80:	11 c0       	rjmp	.+34     	; 0xfa4 <prvUnlockQueue+0x84>
     f82:	f8 01       	movw	r30, r16
     f84:	90 85       	ldd	r25, Z+8	; 0x08
     f86:	91 11       	cpse	r25, r1
     f88:	05 c0       	rjmp	.+10     	; 0xf94 <prvUnlockQueue+0x74>
     f8a:	0c c0       	rjmp	.+24     	; 0xfa4 <prvUnlockQueue+0x84>
     f8c:	78 01       	movw	r14, r16
     f8e:	f8 e0       	ldi	r31, 0x08	; 8
     f90:	ef 0e       	add	r14, r31
     f92:	f1 1c       	adc	r15, r1
     f94:	c7 01       	movw	r24, r14
     f96:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
     f9a:	81 11       	cpse	r24, r1
     f9c:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <vTaskMissedYield>
     fa0:	c1 50       	subi	r28, 0x01	; 1
     fa2:	79 f7       	brne	.-34     	; 0xf82 <prvUnlockQueue+0x62>
     fa4:	8f ef       	ldi	r24, 0xFF	; 255
     fa6:	f8 01       	movw	r30, r16
     fa8:	85 8f       	std	Z+29, r24	; 0x1d
     faa:	0f 90       	pop	r0
     fac:	0f be       	out	0x3f, r0	; 63
     fae:	cf 91       	pop	r28
     fb0:	1f 91       	pop	r17
     fb2:	0f 91       	pop	r16
     fb4:	ff 90       	pop	r15
     fb6:	ef 90       	pop	r14
     fb8:	08 95       	ret

00000fba <xQueueGenericReset>:
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	ec 01       	movw	r28, r24
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	0f 92       	push	r0
     fc6:	48 81       	ld	r20, Y
     fc8:	59 81       	ldd	r21, Y+1	; 0x01
     fca:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fcc:	30 e0       	ldi	r19, 0x00	; 0
     fce:	7b 8d       	ldd	r23, Y+27	; 0x1b
     fd0:	72 9f       	mul	r23, r18
     fd2:	c0 01       	movw	r24, r0
     fd4:	73 9f       	mul	r23, r19
     fd6:	90 0d       	add	r25, r0
     fd8:	11 24       	eor	r1, r1
     fda:	fa 01       	movw	r30, r20
     fdc:	e8 0f       	add	r30, r24
     fde:	f9 1f       	adc	r31, r25
     fe0:	fb 83       	std	Y+3, r31	; 0x03
     fe2:	ea 83       	std	Y+2, r30	; 0x02
     fe4:	1a 8e       	std	Y+26, r1	; 0x1a
     fe6:	5d 83       	std	Y+5, r21	; 0x05
     fe8:	4c 83       	std	Y+4, r20	; 0x04
     fea:	82 1b       	sub	r24, r18
     fec:	93 0b       	sbc	r25, r19
     fee:	84 0f       	add	r24, r20
     ff0:	95 1f       	adc	r25, r21
     ff2:	9f 83       	std	Y+7, r25	; 0x07
     ff4:	8e 83       	std	Y+6, r24	; 0x06
     ff6:	8f ef       	ldi	r24, 0xFF	; 255
     ff8:	8d 8f       	std	Y+29, r24	; 0x1d
     ffa:	8e 8f       	std	Y+30, r24	; 0x1e
     ffc:	61 11       	cpse	r22, r1
     ffe:	0c c0       	rjmp	.+24     	; 0x1018 <xQueueGenericReset+0x5e>
    1000:	88 85       	ldd	r24, Y+8	; 0x08
    1002:	88 23       	and	r24, r24
    1004:	89 f0       	breq	.+34     	; 0x1028 <xQueueGenericReset+0x6e>
    1006:	ce 01       	movw	r24, r28
    1008:	08 96       	adiw	r24, 0x08	; 8
    100a:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
    100e:	88 23       	and	r24, r24
    1010:	59 f0       	breq	.+22     	; 0x1028 <xQueueGenericReset+0x6e>
    1012:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    1016:	08 c0       	rjmp	.+16     	; 0x1028 <xQueueGenericReset+0x6e>
    1018:	ce 01       	movw	r24, r28
    101a:	08 96       	adiw	r24, 0x08	; 8
    101c:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    1020:	ce 01       	movw	r24, r28
    1022:	41 96       	adiw	r24, 0x11	; 17
    1024:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    1028:	0f 90       	pop	r0
    102a:	0f be       	out	0x3f, r0	; 63
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	08 95       	ret

00001034 <xQueueGenericCreate>:
    1034:	0f 93       	push	r16
    1036:	1f 93       	push	r17
    1038:	cf 93       	push	r28
    103a:	df 93       	push	r29
    103c:	08 2f       	mov	r16, r24
    103e:	16 2f       	mov	r17, r22
    1040:	66 23       	and	r22, r22
    1042:	c1 f0       	breq	.+48     	; 0x1074 <xQueueGenericCreate+0x40>
    1044:	86 9f       	mul	r24, r22
    1046:	c0 01       	movw	r24, r0
    1048:	11 24       	eor	r1, r1
    104a:	4f 96       	adiw	r24, 0x1f	; 31
    104c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1050:	ec 01       	movw	r28, r24
    1052:	00 97       	sbiw	r24, 0x00	; 0
    1054:	41 f4       	brne	.+16     	; 0x1066 <xQueueGenericCreate+0x32>
    1056:	15 c0       	rjmp	.+42     	; 0x1082 <xQueueGenericCreate+0x4e>
    1058:	0b 8f       	std	Y+27, r16	; 0x1b
    105a:	1c 8f       	std	Y+28, r17	; 0x1c
    105c:	61 e0       	ldi	r22, 0x01	; 1
    105e:	ce 01       	movw	r24, r28
    1060:	0e 94 dd 07 	call	0xfba	; 0xfba <xQueueGenericReset>
    1064:	0e c0       	rjmp	.+28     	; 0x1082 <xQueueGenericCreate+0x4e>
    1066:	4f 96       	adiw	r24, 0x1f	; 31
    1068:	99 83       	std	Y+1, r25	; 0x01
    106a:	88 83       	st	Y, r24
    106c:	f5 cf       	rjmp	.-22     	; 0x1058 <xQueueGenericCreate+0x24>
    106e:	d9 83       	std	Y+1, r29	; 0x01
    1070:	c8 83       	st	Y, r28
    1072:	f2 cf       	rjmp	.-28     	; 0x1058 <xQueueGenericCreate+0x24>
    1074:	8f e1       	ldi	r24, 0x1F	; 31
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    107c:	ec 01       	movw	r28, r24
    107e:	89 2b       	or	r24, r25
    1080:	b1 f7       	brne	.-20     	; 0x106e <xQueueGenericCreate+0x3a>
    1082:	ce 01       	movw	r24, r28
    1084:	df 91       	pop	r29
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	08 95       	ret

0000108e <xQueueGenericSend>:
    108e:	9f 92       	push	r9
    1090:	af 92       	push	r10
    1092:	bf 92       	push	r11
    1094:	cf 92       	push	r12
    1096:	df 92       	push	r13
    1098:	ef 92       	push	r14
    109a:	ff 92       	push	r15
    109c:	0f 93       	push	r16
    109e:	1f 93       	push	r17
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	00 d0       	rcall	.+0      	; 0x10a6 <xQueueGenericSend+0x18>
    10a6:	00 d0       	rcall	.+0      	; 0x10a8 <xQueueGenericSend+0x1a>
    10a8:	1f 92       	push	r1
    10aa:	cd b7       	in	r28, 0x3d	; 61
    10ac:	de b7       	in	r29, 0x3e	; 62
    10ae:	8c 01       	movw	r16, r24
    10b0:	6b 01       	movw	r12, r22
    10b2:	5d 83       	std	Y+5, r21	; 0x05
    10b4:	4c 83       	std	Y+4, r20	; 0x04
    10b6:	a2 2e       	mov	r10, r18
    10b8:	b1 2c       	mov	r11, r1
    10ba:	99 24       	eor	r9, r9
    10bc:	93 94       	inc	r9
    10be:	7c 01       	movw	r14, r24
    10c0:	88 e0       	ldi	r24, 0x08	; 8
    10c2:	e8 0e       	add	r14, r24
    10c4:	f1 1c       	adc	r15, r1
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	0f 92       	push	r0
    10cc:	f8 01       	movw	r30, r16
    10ce:	32 8d       	ldd	r19, Z+26	; 0x1a
    10d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    10d2:	39 17       	cp	r19, r25
    10d4:	18 f0       	brcs	.+6      	; 0x10dc <xQueueGenericSend+0x4e>
    10d6:	f2 e0       	ldi	r31, 0x02	; 2
    10d8:	af 12       	cpse	r10, r31
    10da:	19 c0       	rjmp	.+50     	; 0x110e <xQueueGenericSend+0x80>
    10dc:	4a 2d       	mov	r20, r10
    10de:	b6 01       	movw	r22, r12
    10e0:	c8 01       	movw	r24, r16
    10e2:	0e 94 15 07 	call	0xe2a	; 0xe2a <prvCopyDataToQueue>
    10e6:	f8 01       	movw	r30, r16
    10e8:	91 89       	ldd	r25, Z+17	; 0x11
    10ea:	99 23       	and	r25, r25
    10ec:	49 f0       	breq	.+18     	; 0x1100 <xQueueGenericSend+0x72>
    10ee:	c8 01       	movw	r24, r16
    10f0:	41 96       	adiw	r24, 0x11	; 17
    10f2:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
    10f6:	88 23       	and	r24, r24
    10f8:	31 f0       	breq	.+12     	; 0x1106 <xQueueGenericSend+0x78>
    10fa:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    10fe:	03 c0       	rjmp	.+6      	; 0x1106 <xQueueGenericSend+0x78>
    1100:	81 11       	cpse	r24, r1
    1102:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    1106:	0f 90       	pop	r0
    1108:	0f be       	out	0x3f, r0	; 63
    110a:	81 e0       	ldi	r24, 0x01	; 1
    110c:	50 c0       	rjmp	.+160    	; 0x11ae <xQueueGenericSend+0x120>
    110e:	ec 81       	ldd	r30, Y+4	; 0x04
    1110:	fd 81       	ldd	r31, Y+5	; 0x05
    1112:	ef 2b       	or	r30, r31
    1114:	21 f4       	brne	.+8      	; 0x111e <xQueueGenericSend+0x90>
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	48 c0       	rjmp	.+144    	; 0x11ae <xQueueGenericSend+0x120>
    111e:	b1 10       	cpse	r11, r1
    1120:	05 c0       	rjmp	.+10     	; 0x112c <xQueueGenericSend+0x9e>
    1122:	ce 01       	movw	r24, r28
    1124:	01 96       	adiw	r24, 0x01	; 1
    1126:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vTaskSetTimeOutState>
    112a:	b9 2c       	mov	r11, r9
    112c:	0f 90       	pop	r0
    112e:	0f be       	out	0x3f, r0	; 63
    1130:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	f8 94       	cli
    1138:	0f 92       	push	r0
    113a:	f8 01       	movw	r30, r16
    113c:	85 8d       	ldd	r24, Z+29	; 0x1d
    113e:	8f 3f       	cpi	r24, 0xFF	; 255
    1140:	09 f4       	brne	.+2      	; 0x1144 <xQueueGenericSend+0xb6>
    1142:	15 8e       	std	Z+29, r1	; 0x1d
    1144:	f8 01       	movw	r30, r16
    1146:	86 8d       	ldd	r24, Z+30	; 0x1e
    1148:	8f 3f       	cpi	r24, 0xFF	; 255
    114a:	09 f4       	brne	.+2      	; 0x114e <xQueueGenericSend+0xc0>
    114c:	16 8e       	std	Z+30, r1	; 0x1e
    114e:	0f 90       	pop	r0
    1150:	0f be       	out	0x3f, r0	; 63
    1152:	be 01       	movw	r22, r28
    1154:	6c 5f       	subi	r22, 0xFC	; 252
    1156:	7f 4f       	sbci	r23, 0xFF	; 255
    1158:	ce 01       	movw	r24, r28
    115a:	01 96       	adiw	r24, 0x01	; 1
    115c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <xTaskCheckForTimeOut>
    1160:	81 11       	cpse	r24, r1
    1162:	1f c0       	rjmp	.+62     	; 0x11a2 <xQueueGenericSend+0x114>
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
    116a:	f8 01       	movw	r30, r16
    116c:	92 8d       	ldd	r25, Z+26	; 0x1a
    116e:	0f 90       	pop	r0
    1170:	0f be       	out	0x3f, r0	; 63
    1172:	83 8d       	ldd	r24, Z+27	; 0x1b
    1174:	98 13       	cpse	r25, r24
    1176:	0f c0       	rjmp	.+30     	; 0x1196 <xQueueGenericSend+0x108>
    1178:	6c 81       	ldd	r22, Y+4	; 0x04
    117a:	7d 81       	ldd	r23, Y+5	; 0x05
    117c:	c7 01       	movw	r24, r14
    117e:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <vTaskPlaceOnEventList>
    1182:	c8 01       	movw	r24, r16
    1184:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
    1188:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    118c:	81 11       	cpse	r24, r1
    118e:	9b cf       	rjmp	.-202    	; 0x10c6 <xQueueGenericSend+0x38>
    1190:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    1194:	98 cf       	rjmp	.-208    	; 0x10c6 <xQueueGenericSend+0x38>
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
    119c:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    11a0:	92 cf       	rjmp	.-220    	; 0x10c6 <xQueueGenericSend+0x38>
    11a2:	c8 01       	movw	r24, r16
    11a4:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
    11a8:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	9f 90       	pop	r9
    11ce:	08 95       	ret

000011d0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    11d0:	8f 92       	push	r8
    11d2:	9f 92       	push	r9
    11d4:	af 92       	push	r10
    11d6:	bf 92       	push	r11
    11d8:	cf 92       	push	r12
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	00 d0       	rcall	.+0      	; 0x11ea <xQueueGenericReceive+0x1a>
    11ea:	00 d0       	rcall	.+0      	; 0x11ec <xQueueGenericReceive+0x1c>
    11ec:	1f 92       	push	r1
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
    11f2:	8c 01       	movw	r16, r24
    11f4:	5b 01       	movw	r10, r22
    11f6:	5d 83       	std	Y+5, r21	; 0x05
    11f8:	4c 83       	std	Y+4, r20	; 0x04
    11fa:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    11fc:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    11fe:	99 24       	eor	r9, r9
    1200:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1202:	6c 01       	movw	r12, r24
    1204:	81 e1       	ldi	r24, 0x11	; 17
    1206:	c8 0e       	add	r12, r24
    1208:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1210:	f8 01       	movw	r30, r16
    1212:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1214:	ff 20       	and	r15, r15
    1216:	91 f1       	breq	.+100    	; 0x127c <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1218:	c6 80       	ldd	r12, Z+6	; 0x06
    121a:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    121c:	b5 01       	movw	r22, r10
    121e:	c8 01       	movw	r24, r16
    1220:	0e 94 76 07 	call	0xeec	; 0xeec <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1224:	81 10       	cpse	r8, r1
    1226:	19 c0       	rjmp	.+50     	; 0x125a <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1228:	fa 94       	dec	r15
    122a:	f8 01       	movw	r30, r16
    122c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    122e:	80 81       	ld	r24, Z
    1230:	91 81       	ldd	r25, Z+1	; 0x01
    1232:	89 2b       	or	r24, r25
    1234:	29 f4       	brne	.+10     	; 0x1240 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1236:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <pvTaskIncrementMutexHeldCount>
    123a:	f8 01       	movw	r30, r16
    123c:	93 83       	std	Z+3, r25	; 0x03
    123e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1240:	f8 01       	movw	r30, r16
    1242:	80 85       	ldd	r24, Z+8	; 0x08
    1244:	88 23       	and	r24, r24
    1246:	b1 f0       	breq	.+44     	; 0x1274 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1248:	c8 01       	movw	r24, r16
    124a:	08 96       	adiw	r24, 0x08	; 8
    124c:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
    1250:	88 23       	and	r24, r24
    1252:	81 f0       	breq	.+32     	; 0x1274 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1254:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    1258:	0d c0       	rjmp	.+26     	; 0x1274 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    125a:	f8 01       	movw	r30, r16
    125c:	d7 82       	std	Z+7, r13	; 0x07
    125e:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1260:	81 89       	ldd	r24, Z+17	; 0x11
    1262:	88 23       	and	r24, r24
    1264:	39 f0       	breq	.+14     	; 0x1274 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1266:	c8 01       	movw	r24, r16
    1268:	41 96       	adiw	r24, 0x11	; 17
    126a:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <xTaskRemoveFromEventList>
    126e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1270:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1274:	0f 90       	pop	r0
    1276:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	64 c0       	rjmp	.+200    	; 0x1344 <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    127c:	4c 81       	ldd	r20, Y+4	; 0x04
    127e:	5d 81       	ldd	r21, Y+5	; 0x05
    1280:	45 2b       	or	r20, r21
    1282:	21 f4       	brne	.+8      	; 0x128c <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1284:	0f 90       	pop	r0
    1286:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1288:	80 e0       	ldi	r24, 0x00	; 0
    128a:	5c c0       	rjmp	.+184    	; 0x1344 <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    128c:	e1 10       	cpse	r14, r1
    128e:	05 c0       	rjmp	.+10     	; 0x129a <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1290:	ce 01       	movw	r24, r28
    1292:	01 96       	adiw	r24, 0x01	; 1
    1294:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1298:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    129a:	0f 90       	pop	r0
    129c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    129e:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	f8 94       	cli
    12a6:	0f 92       	push	r0
    12a8:	f8 01       	movw	r30, r16
    12aa:	85 8d       	ldd	r24, Z+29	; 0x1d
    12ac:	8f 3f       	cpi	r24, 0xFF	; 255
    12ae:	09 f4       	brne	.+2      	; 0x12b2 <xQueueGenericReceive+0xe2>
    12b0:	15 8e       	std	Z+29, r1	; 0x1d
    12b2:	f8 01       	movw	r30, r16
    12b4:	96 8d       	ldd	r25, Z+30	; 0x1e
    12b6:	9f 3f       	cpi	r25, 0xFF	; 255
    12b8:	09 f4       	brne	.+2      	; 0x12bc <xQueueGenericReceive+0xec>
    12ba:	16 8e       	std	Z+30, r1	; 0x1e
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12c0:	be 01       	movw	r22, r28
    12c2:	6c 5f       	subi	r22, 0xFC	; 252
    12c4:	7f 4f       	sbci	r23, 0xFF	; 255
    12c6:	ce 01       	movw	r24, r28
    12c8:	01 96       	adiw	r24, 0x01	; 1
    12ca:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <xTaskCheckForTimeOut>
    12ce:	81 11       	cpse	r24, r1
    12d0:	2b c0       	rjmp	.+86     	; 0x1328 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12d2:	0f b6       	in	r0, 0x3f	; 63
    12d4:	f8 94       	cli
    12d6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12d8:	f8 01       	movw	r30, r16
    12da:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12dc:	0f 90       	pop	r0
    12de:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12e0:	81 11       	cpse	r24, r1
    12e2:	1c c0       	rjmp	.+56     	; 0x131c <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12e4:	80 81       	ld	r24, Z
    12e6:	91 81       	ldd	r25, Z+1	; 0x01
    12e8:	89 2b       	or	r24, r25
    12ea:	49 f4       	brne	.+18     	; 0x12fe <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
    12ec:	0f b6       	in	r0, 0x3f	; 63
    12ee:	f8 94       	cli
    12f0:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    12f2:	82 81       	ldd	r24, Z+2	; 0x02
    12f4:	93 81       	ldd	r25, Z+3	; 0x03
    12f6:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12fe:	6c 81       	ldd	r22, Y+4	; 0x04
    1300:	7d 81       	ldd	r23, Y+5	; 0x05
    1302:	c6 01       	movw	r24, r12
    1304:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1308:	c8 01       	movw	r24, r16
    130a:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    130e:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    1312:	81 11       	cpse	r24, r1
    1314:	7a cf       	rjmp	.-268    	; 0x120a <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    1316:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    131a:	77 cf       	rjmp	.-274    	; 0x120a <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    131c:	c8 01       	movw	r24, r16
    131e:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1322:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    1326:	71 cf       	rjmp	.-286    	; 0x120a <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1328:	c8 01       	movw	r24, r16
    132a:	0e 94 90 07 	call	0xf20	; 0xf20 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    132e:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	f8 94       	cli
    1336:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1338:	f8 01       	movw	r30, r16
    133a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    133c:	0f 90       	pop	r0
    133e:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1340:	81 11       	cpse	r24, r1
    1342:	63 cf       	rjmp	.-314    	; 0x120a <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1344:	0f 90       	pop	r0
    1346:	0f 90       	pop	r0
    1348:	0f 90       	pop	r0
    134a:	0f 90       	pop	r0
    134c:	0f 90       	pop	r0
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	1f 91       	pop	r17
    1354:	0f 91       	pop	r16
    1356:	ff 90       	pop	r15
    1358:	ef 90       	pop	r14
    135a:	df 90       	pop	r13
    135c:	cf 90       	pop	r12
    135e:	bf 90       	pop	r11
    1360:	af 90       	pop	r10
    1362:	9f 90       	pop	r9
    1364:	8f 90       	pop	r8
    1366:	08 95       	ret

00001368 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1368:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxDelayedTaskList>
    136c:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    1370:	80 81       	ld	r24, Z
    1372:	81 11       	cpse	r24, r1
    1374:	07 c0       	rjmp	.+14     	; 0x1384 <prvResetNextTaskUnblockTime+0x1c>
    1376:	8f ef       	ldi	r24, 0xFF	; 255
    1378:	9f ef       	ldi	r25, 0xFF	; 255
    137a:	90 93 e5 04 	sts	0x04E5, r25	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    137e:	80 93 e4 04 	sts	0x04E4, r24	; 0x8004e4 <xNextTaskUnblockTime>
    1382:	08 95       	ret
    1384:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxDelayedTaskList>
    1388:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    138c:	05 80       	ldd	r0, Z+5	; 0x05
    138e:	f6 81       	ldd	r31, Z+6	; 0x06
    1390:	e0 2d       	mov	r30, r0
    1392:	06 80       	ldd	r0, Z+6	; 0x06
    1394:	f7 81       	ldd	r31, Z+7	; 0x07
    1396:	e0 2d       	mov	r30, r0
    1398:	82 81       	ldd	r24, Z+2	; 0x02
    139a:	93 81       	ldd	r25, Z+3	; 0x03
    139c:	90 93 e5 04 	sts	0x04E5, r25	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    13a0:	80 93 e4 04 	sts	0x04E4, r24	; 0x8004e4 <xNextTaskUnblockTime>
    13a4:	08 95       	ret

000013a6 <prvAddCurrentTaskToDelayedList>:
    13a6:	ff 92       	push	r15
    13a8:	0f 93       	push	r16
    13aa:	1f 93       	push	r17
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	ec 01       	movw	r28, r24
    13b2:	f6 2e       	mov	r15, r22
    13b4:	00 91 ec 04 	lds	r16, 0x04EC	; 0x8004ec <xTickCount>
    13b8:	10 91 ed 04 	lds	r17, 0x04ED	; 0x8004ed <xTickCount+0x1>
    13bc:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <pxCurrentTCB>
    13c0:	90 91 4f 05 	lds	r25, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    13c4:	02 96       	adiw	r24, 0x02	; 2
    13c6:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    13ca:	cf 3f       	cpi	r28, 0xFF	; 255
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	d8 07       	cpc	r29, r24
    13d0:	69 f4       	brne	.+26     	; 0x13ec <prvAddCurrentTaskToDelayedList+0x46>
    13d2:	ff 20       	and	r15, r15
    13d4:	59 f0       	breq	.+22     	; 0x13ec <prvAddCurrentTaskToDelayedList+0x46>
    13d6:	60 91 4e 05 	lds	r22, 0x054E	; 0x80054e <pxCurrentTCB>
    13da:	70 91 4f 05 	lds	r23, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    13de:	6e 5f       	subi	r22, 0xFE	; 254
    13e0:	7f 4f       	sbci	r23, 0xFF	; 255
    13e2:	8f ee       	ldi	r24, 0xEF	; 239
    13e4:	94 e0       	ldi	r25, 0x04	; 4
    13e6:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    13ea:	2f c0       	rjmp	.+94     	; 0x144a <prvAddCurrentTaskToDelayedList+0xa4>
    13ec:	c0 0f       	add	r28, r16
    13ee:	d1 1f       	adc	r29, r17
    13f0:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    13f4:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    13f8:	d3 83       	std	Z+3, r29	; 0x03
    13fa:	c2 83       	std	Z+2, r28	; 0x02
    13fc:	c0 17       	cp	r28, r16
    13fe:	d1 07       	cpc	r29, r17
    1400:	68 f4       	brcc	.+26     	; 0x141c <prvAddCurrentTaskToDelayedList+0x76>
    1402:	60 91 4e 05 	lds	r22, 0x054E	; 0x80054e <pxCurrentTCB>
    1406:	70 91 4f 05 	lds	r23, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    140a:	80 91 0b 05 	lds	r24, 0x050B	; 0x80050b <pxOverflowDelayedTaskList>
    140e:	90 91 0c 05 	lds	r25, 0x050C	; 0x80050c <pxOverflowDelayedTaskList+0x1>
    1412:	6e 5f       	subi	r22, 0xFE	; 254
    1414:	7f 4f       	sbci	r23, 0xFF	; 255
    1416:	0e 94 35 03 	call	0x66a	; 0x66a <vListInsert>
    141a:	17 c0       	rjmp	.+46     	; 0x144a <prvAddCurrentTaskToDelayedList+0xa4>
    141c:	60 91 4e 05 	lds	r22, 0x054E	; 0x80054e <pxCurrentTCB>
    1420:	70 91 4f 05 	lds	r23, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1424:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <pxDelayedTaskList>
    1428:	90 91 0e 05 	lds	r25, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    142c:	6e 5f       	subi	r22, 0xFE	; 254
    142e:	7f 4f       	sbci	r23, 0xFF	; 255
    1430:	0e 94 35 03 	call	0x66a	; 0x66a <vListInsert>
    1434:	80 91 e4 04 	lds	r24, 0x04E4	; 0x8004e4 <xNextTaskUnblockTime>
    1438:	90 91 e5 04 	lds	r25, 0x04E5	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    143c:	c8 17       	cp	r28, r24
    143e:	d9 07       	cpc	r29, r25
    1440:	20 f4       	brcc	.+8      	; 0x144a <prvAddCurrentTaskToDelayedList+0xa4>
    1442:	d0 93 e5 04 	sts	0x04E5, r29	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    1446:	c0 93 e4 04 	sts	0x04E4, r28	; 0x8004e4 <xNextTaskUnblockTime>
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	ff 90       	pop	r15
    1454:	08 95       	ret

00001456 <xTaskCreate>:
    1456:	4f 92       	push	r4
    1458:	5f 92       	push	r5
    145a:	6f 92       	push	r6
    145c:	7f 92       	push	r7
    145e:	8f 92       	push	r8
    1460:	9f 92       	push	r9
    1462:	af 92       	push	r10
    1464:	bf 92       	push	r11
    1466:	cf 92       	push	r12
    1468:	df 92       	push	r13
    146a:	ef 92       	push	r14
    146c:	ff 92       	push	r15
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	4c 01       	movw	r8, r24
    1478:	6b 01       	movw	r12, r22
    147a:	5a 01       	movw	r10, r20
    147c:	29 01       	movw	r4, r18
    147e:	ca 01       	movw	r24, r20
    1480:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1484:	3c 01       	movw	r6, r24
    1486:	89 2b       	or	r24, r25
    1488:	09 f4       	brne	.+2      	; 0x148c <xTaskCreate+0x36>
    148a:	e4 c0       	rjmp	.+456    	; 0x1654 <xTaskCreate+0x1fe>
    148c:	8a e2       	ldi	r24, 0x2A	; 42
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1494:	ec 01       	movw	r28, r24
    1496:	89 2b       	or	r24, r25
    1498:	71 f0       	breq	.+28     	; 0x14b6 <xTaskCreate+0x60>
    149a:	78 8e       	std	Y+24, r7	; 0x18
    149c:	6f 8a       	std	Y+23, r6	; 0x17
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	a8 1a       	sub	r10, r24
    14a2:	b1 08       	sbc	r11, r1
    14a4:	6a 0c       	add	r6, r10
    14a6:	7b 1c       	adc	r7, r11
    14a8:	d6 01       	movw	r26, r12
    14aa:	8c 91       	ld	r24, X
    14ac:	89 8f       	std	Y+25, r24	; 0x19
    14ae:	8c 91       	ld	r24, X
    14b0:	81 11       	cpse	r24, r1
    14b2:	05 c0       	rjmp	.+10     	; 0x14be <xTaskCreate+0x68>
    14b4:	18 c0       	rjmp	.+48     	; 0x14e6 <xTaskCreate+0x90>
    14b6:	c3 01       	movw	r24, r6
    14b8:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    14bc:	cb c0       	rjmp	.+406    	; 0x1654 <xTaskCreate+0x1fe>
    14be:	ae 01       	movw	r20, r28
    14c0:	46 5e       	subi	r20, 0xE6	; 230
    14c2:	5f 4f       	sbci	r21, 0xFF	; 255
    14c4:	f6 01       	movw	r30, r12
    14c6:	31 96       	adiw	r30, 0x01	; 1
    14c8:	ba e0       	ldi	r27, 0x0A	; 10
    14ca:	cb 0e       	add	r12, r27
    14cc:	d1 1c       	adc	r13, r1
    14ce:	cf 01       	movw	r24, r30
    14d0:	21 91       	ld	r18, Z+
    14d2:	da 01       	movw	r26, r20
    14d4:	2d 93       	st	X+, r18
    14d6:	ad 01       	movw	r20, r26
    14d8:	dc 01       	movw	r26, r24
    14da:	8c 91       	ld	r24, X
    14dc:	88 23       	and	r24, r24
    14de:	19 f0       	breq	.+6      	; 0x14e6 <xTaskCreate+0x90>
    14e0:	ec 15       	cp	r30, r12
    14e2:	fd 05       	cpc	r31, r13
    14e4:	a1 f7       	brne	.-24     	; 0x14ce <xTaskCreate+0x78>
    14e6:	1a a2       	std	Y+34, r1	; 0x22
    14e8:	05 30       	cpi	r16, 0x05	; 5
    14ea:	08 f0       	brcs	.+2      	; 0x14ee <xTaskCreate+0x98>
    14ec:	04 e0       	ldi	r16, 0x04	; 4
    14ee:	0e 8b       	std	Y+22, r16	; 0x16
    14f0:	0b a3       	std	Y+35, r16	; 0x23
    14f2:	1c a2       	std	Y+36, r1	; 0x24
    14f4:	6e 01       	movw	r12, r28
    14f6:	b2 e0       	ldi	r27, 0x02	; 2
    14f8:	cb 0e       	add	r12, r27
    14fa:	d1 1c       	adc	r13, r1
    14fc:	c6 01       	movw	r24, r12
    14fe:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialiseItem>
    1502:	ce 01       	movw	r24, r28
    1504:	0c 96       	adiw	r24, 0x0c	; 12
    1506:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialiseItem>
    150a:	d9 87       	std	Y+9, r29	; 0x09
    150c:	c8 87       	std	Y+8, r28	; 0x08
    150e:	85 e0       	ldi	r24, 0x05	; 5
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	80 1b       	sub	r24, r16
    1514:	91 09       	sbc	r25, r1
    1516:	9d 87       	std	Y+13, r25	; 0x0d
    1518:	8c 87       	std	Y+12, r24	; 0x0c
    151a:	db 8b       	std	Y+19, r29	; 0x13
    151c:	ca 8b       	std	Y+18, r28	; 0x12
    151e:	1d a2       	std	Y+37, r1	; 0x25
    1520:	1e a2       	std	Y+38, r1	; 0x26
    1522:	1f a2       	std	Y+39, r1	; 0x27
    1524:	18 a6       	std	Y+40, r1	; 0x28
    1526:	19 a6       	std	Y+41, r1	; 0x29
    1528:	a2 01       	movw	r20, r4
    152a:	b4 01       	movw	r22, r8
    152c:	c3 01       	movw	r24, r6
    152e:	0e 94 bc 05 	call	0xb78	; 0xb78 <pxPortInitialiseStack>
    1532:	99 83       	std	Y+1, r25	; 0x01
    1534:	88 83       	st	Y, r24
    1536:	e1 14       	cp	r14, r1
    1538:	f1 04       	cpc	r15, r1
    153a:	19 f0       	breq	.+6      	; 0x1542 <xTaskCreate+0xec>
    153c:	f7 01       	movw	r30, r14
    153e:	d1 83       	std	Z+1, r29	; 0x01
    1540:	c0 83       	st	Z, r28
    1542:	0f b6       	in	r0, 0x3f	; 63
    1544:	f8 94       	cli
    1546:	0f 92       	push	r0
    1548:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <uxCurrentNumberOfTasks>
    154c:	8f 5f       	subi	r24, 0xFF	; 255
    154e:	80 93 ee 04 	sts	0x04EE, r24	; 0x8004ee <uxCurrentNumberOfTasks>
    1552:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <pxCurrentTCB>
    1556:	90 91 4f 05 	lds	r25, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    155a:	89 2b       	or	r24, r25
    155c:	d1 f5       	brne	.+116    	; 0x15d2 <xTaskCreate+0x17c>
    155e:	d0 93 4f 05 	sts	0x054F, r29	; 0x80054f <pxCurrentTCB+0x1>
    1562:	c0 93 4e 05 	sts	0x054E, r28	; 0x80054e <pxCurrentTCB>
    1566:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <uxCurrentNumberOfTasks>
    156a:	81 30       	cpi	r24, 0x01	; 1
    156c:	09 f0       	breq	.+2      	; 0x1570 <xTaskCreate+0x11a>
    156e:	41 c0       	rjmp	.+130    	; 0x15f2 <xTaskCreate+0x19c>
    1570:	01 e2       	ldi	r16, 0x21	; 33
    1572:	15 e0       	ldi	r17, 0x05	; 5
    1574:	0f 2e       	mov	r0, r31
    1576:	fe e4       	ldi	r31, 0x4E	; 78
    1578:	ef 2e       	mov	r14, r31
    157a:	f5 e0       	ldi	r31, 0x05	; 5
    157c:	ff 2e       	mov	r15, r31
    157e:	f0 2d       	mov	r31, r0
    1580:	c8 01       	movw	r24, r16
    1582:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    1586:	07 5f       	subi	r16, 0xF7	; 247
    1588:	1f 4f       	sbci	r17, 0xFF	; 255
    158a:	0e 15       	cp	r16, r14
    158c:	1f 05       	cpc	r17, r15
    158e:	c1 f7       	brne	.-16     	; 0x1580 <xTaskCreate+0x12a>
    1590:	88 e1       	ldi	r24, 0x18	; 24
    1592:	95 e0       	ldi	r25, 0x05	; 5
    1594:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    1598:	8f e0       	ldi	r24, 0x0F	; 15
    159a:	95 e0       	ldi	r25, 0x05	; 5
    159c:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    15a0:	82 e0       	ldi	r24, 0x02	; 2
    15a2:	95 e0       	ldi	r25, 0x05	; 5
    15a4:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    15a8:	89 ef       	ldi	r24, 0xF9	; 249
    15aa:	94 e0       	ldi	r25, 0x04	; 4
    15ac:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    15b0:	8f ee       	ldi	r24, 0xEF	; 239
    15b2:	94 e0       	ldi	r25, 0x04	; 4
    15b4:	0e 94 02 03 	call	0x604	; 0x604 <vListInitialise>
    15b8:	88 e1       	ldi	r24, 0x18	; 24
    15ba:	95 e0       	ldi	r25, 0x05	; 5
    15bc:	90 93 0e 05 	sts	0x050E, r25	; 0x80050e <pxDelayedTaskList+0x1>
    15c0:	80 93 0d 05 	sts	0x050D, r24	; 0x80050d <pxDelayedTaskList>
    15c4:	8f e0       	ldi	r24, 0x0F	; 15
    15c6:	95 e0       	ldi	r25, 0x05	; 5
    15c8:	90 93 0c 05 	sts	0x050C, r25	; 0x80050c <pxOverflowDelayedTaskList+0x1>
    15cc:	80 93 0b 05 	sts	0x050B, r24	; 0x80050b <pxOverflowDelayedTaskList>
    15d0:	10 c0       	rjmp	.+32     	; 0x15f2 <xTaskCreate+0x19c>
    15d2:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <xSchedulerRunning>
    15d6:	81 11       	cpse	r24, r1
    15d8:	0c c0       	rjmp	.+24     	; 0x15f2 <xTaskCreate+0x19c>
    15da:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    15de:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    15e2:	96 89       	ldd	r25, Z+22	; 0x16
    15e4:	8e 89       	ldd	r24, Y+22	; 0x16
    15e6:	89 17       	cp	r24, r25
    15e8:	20 f0       	brcs	.+8      	; 0x15f2 <xTaskCreate+0x19c>
    15ea:	d0 93 4f 05 	sts	0x054F, r29	; 0x80054f <pxCurrentTCB+0x1>
    15ee:	c0 93 4e 05 	sts	0x054E, r28	; 0x80054e <pxCurrentTCB>
    15f2:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <uxTaskNumber>
    15f6:	8f 5f       	subi	r24, 0xFF	; 255
    15f8:	80 93 e6 04 	sts	0x04E6, r24	; 0x8004e6 <uxTaskNumber>
    15fc:	8e 89       	ldd	r24, Y+22	; 0x16
    15fe:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1602:	98 17       	cp	r25, r24
    1604:	10 f4       	brcc	.+4      	; 0x160a <xTaskCreate+0x1b4>
    1606:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <uxTopReadyPriority>
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	9c 01       	movw	r18, r24
    160e:	22 0f       	add	r18, r18
    1610:	33 1f       	adc	r19, r19
    1612:	22 0f       	add	r18, r18
    1614:	33 1f       	adc	r19, r19
    1616:	22 0f       	add	r18, r18
    1618:	33 1f       	adc	r19, r19
    161a:	82 0f       	add	r24, r18
    161c:	93 1f       	adc	r25, r19
    161e:	b6 01       	movw	r22, r12
    1620:	8f 5d       	subi	r24, 0xDF	; 223
    1622:	9a 4f       	sbci	r25, 0xFA	; 250
    1624:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63
    162c:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <xSchedulerRunning>
    1630:	88 23       	and	r24, r24
    1632:	61 f0       	breq	.+24     	; 0x164c <xTaskCreate+0x1f6>
    1634:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    1638:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    163c:	96 89       	ldd	r25, Z+22	; 0x16
    163e:	8e 89       	ldd	r24, Y+22	; 0x16
    1640:	98 17       	cp	r25, r24
    1642:	30 f4       	brcc	.+12     	; 0x1650 <xTaskCreate+0x1fa>
    1644:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	05 c0       	rjmp	.+10     	; 0x1656 <xTaskCreate+0x200>
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	03 c0       	rjmp	.+6      	; 0x1656 <xTaskCreate+0x200>
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	01 c0       	rjmp	.+2      	; 0x1656 <xTaskCreate+0x200>
    1654:	8f ef       	ldi	r24, 0xFF	; 255
    1656:	df 91       	pop	r29
    1658:	cf 91       	pop	r28
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	bf 90       	pop	r11
    1668:	af 90       	pop	r10
    166a:	9f 90       	pop	r9
    166c:	8f 90       	pop	r8
    166e:	7f 90       	pop	r7
    1670:	6f 90       	pop	r6
    1672:	5f 90       	pop	r5
    1674:	4f 90       	pop	r4
    1676:	08 95       	ret

00001678 <vTaskStartScheduler>:
    1678:	ef 92       	push	r14
    167a:	ff 92       	push	r15
    167c:	0f 93       	push	r16
    167e:	0f 2e       	mov	r0, r31
    1680:	f2 ee       	ldi	r31, 0xE2	; 226
    1682:	ef 2e       	mov	r14, r31
    1684:	f4 e0       	ldi	r31, 0x04	; 4
    1686:	ff 2e       	mov	r15, r31
    1688:	f0 2d       	mov	r31, r0
    168a:	00 e0       	ldi	r16, 0x00	; 0
    168c:	20 e0       	ldi	r18, 0x00	; 0
    168e:	30 e0       	ldi	r19, 0x00	; 0
    1690:	44 e6       	ldi	r20, 0x64	; 100
    1692:	50 e0       	ldi	r21, 0x00	; 0
    1694:	6c ed       	ldi	r22, 0xDC	; 220
    1696:	70 e0       	ldi	r23, 0x00	; 0
    1698:	8a eb       	ldi	r24, 0xBA	; 186
    169a:	9c e0       	ldi	r25, 0x0C	; 12
    169c:	0e 94 2b 0a 	call	0x1456	; 0x1456 <xTaskCreate>
    16a0:	81 30       	cpi	r24, 0x01	; 1
    16a2:	81 f4       	brne	.+32     	; 0x16c4 <vTaskStartScheduler+0x4c>
    16a4:	f8 94       	cli
    16a6:	8f ef       	ldi	r24, 0xFF	; 255
    16a8:	9f ef       	ldi	r25, 0xFF	; 255
    16aa:	90 93 e5 04 	sts	0x04E5, r25	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    16ae:	80 93 e4 04 	sts	0x04E4, r24	; 0x8004e4 <xNextTaskUnblockTime>
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	80 93 ea 04 	sts	0x04EA, r24	; 0x8004ea <xSchedulerRunning>
    16b8:	10 92 ed 04 	sts	0x04ED, r1	; 0x8004ed <xTickCount+0x1>
    16bc:	10 92 ec 04 	sts	0x04EC, r1	; 0x8004ec <xTickCount>
    16c0:	0e 94 28 06 	call	0xc50	; 0xc50 <xPortStartScheduler>
    16c4:	0f 91       	pop	r16
    16c6:	ff 90       	pop	r15
    16c8:	ef 90       	pop	r14
    16ca:	08 95       	ret

000016cc <vTaskSuspendAll>:
    16cc:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    16d0:	8f 5f       	subi	r24, 0xFF	; 255
    16d2:	80 93 e1 04 	sts	0x04E1, r24	; 0x8004e1 <uxSchedulerSuspended>
    16d6:	08 95       	ret

000016d8 <xTaskIncrementTick>:
    16d8:	cf 92       	push	r12
    16da:	df 92       	push	r13
    16dc:	ef 92       	push	r14
    16de:	ff 92       	push	r15
    16e0:	0f 93       	push	r16
    16e2:	1f 93       	push	r17
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    16ec:	81 11       	cpse	r24, r1
    16ee:	99 c0       	rjmp	.+306    	; 0x1822 <xTaskIncrementTick+0x14a>
    16f0:	e0 90 ec 04 	lds	r14, 0x04EC	; 0x8004ec <xTickCount>
    16f4:	f0 90 ed 04 	lds	r15, 0x04ED	; 0x8004ed <xTickCount+0x1>
    16f8:	8f ef       	ldi	r24, 0xFF	; 255
    16fa:	e8 1a       	sub	r14, r24
    16fc:	f8 0a       	sbc	r15, r24
    16fe:	f0 92 ed 04 	sts	0x04ED, r15	; 0x8004ed <xTickCount+0x1>
    1702:	e0 92 ec 04 	sts	0x04EC, r14	; 0x8004ec <xTickCount>
    1706:	e1 14       	cp	r14, r1
    1708:	f1 04       	cpc	r15, r1
    170a:	b9 f4       	brne	.+46     	; 0x173a <xTaskIncrementTick+0x62>
    170c:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <pxDelayedTaskList>
    1710:	90 91 0e 05 	lds	r25, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    1714:	20 91 0b 05 	lds	r18, 0x050B	; 0x80050b <pxOverflowDelayedTaskList>
    1718:	30 91 0c 05 	lds	r19, 0x050C	; 0x80050c <pxOverflowDelayedTaskList+0x1>
    171c:	30 93 0e 05 	sts	0x050E, r19	; 0x80050e <pxDelayedTaskList+0x1>
    1720:	20 93 0d 05 	sts	0x050D, r18	; 0x80050d <pxDelayedTaskList>
    1724:	90 93 0c 05 	sts	0x050C, r25	; 0x80050c <pxOverflowDelayedTaskList+0x1>
    1728:	80 93 0b 05 	sts	0x050B, r24	; 0x80050b <pxOverflowDelayedTaskList>
    172c:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <xNumOfOverflows>
    1730:	8f 5f       	subi	r24, 0xFF	; 255
    1732:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <xNumOfOverflows>
    1736:	0e 94 b4 09 	call	0x1368	; 0x1368 <prvResetNextTaskUnblockTime>
    173a:	80 91 e4 04 	lds	r24, 0x04E4	; 0x8004e4 <xNextTaskUnblockTime>
    173e:	90 91 e5 04 	lds	r25, 0x04E5	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    1742:	e8 16       	cp	r14, r24
    1744:	f9 06       	cpc	r15, r25
    1746:	10 f4       	brcc	.+4      	; 0x174c <xTaskIncrementTick+0x74>
    1748:	d1 2c       	mov	r13, r1
    174a:	53 c0       	rjmp	.+166    	; 0x17f2 <xTaskIncrementTick+0x11a>
    174c:	d1 2c       	mov	r13, r1
    174e:	cc 24       	eor	r12, r12
    1750:	c3 94       	inc	r12
    1752:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxDelayedTaskList>
    1756:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    175a:	90 81       	ld	r25, Z
    175c:	91 11       	cpse	r25, r1
    175e:	07 c0       	rjmp	.+14     	; 0x176e <xTaskIncrementTick+0x96>
    1760:	8f ef       	ldi	r24, 0xFF	; 255
    1762:	9f ef       	ldi	r25, 0xFF	; 255
    1764:	90 93 e5 04 	sts	0x04E5, r25	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    1768:	80 93 e4 04 	sts	0x04E4, r24	; 0x8004e4 <xNextTaskUnblockTime>
    176c:	42 c0       	rjmp	.+132    	; 0x17f2 <xTaskIncrementTick+0x11a>
    176e:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxDelayedTaskList>
    1772:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxDelayedTaskList+0x1>
    1776:	05 80       	ldd	r0, Z+5	; 0x05
    1778:	f6 81       	ldd	r31, Z+6	; 0x06
    177a:	e0 2d       	mov	r30, r0
    177c:	c6 81       	ldd	r28, Z+6	; 0x06
    177e:	d7 81       	ldd	r29, Z+7	; 0x07
    1780:	2a 81       	ldd	r18, Y+2	; 0x02
    1782:	3b 81       	ldd	r19, Y+3	; 0x03
    1784:	e2 16       	cp	r14, r18
    1786:	f3 06       	cpc	r15, r19
    1788:	28 f4       	brcc	.+10     	; 0x1794 <xTaskIncrementTick+0xbc>
    178a:	30 93 e5 04 	sts	0x04E5, r19	; 0x8004e5 <xNextTaskUnblockTime+0x1>
    178e:	20 93 e4 04 	sts	0x04E4, r18	; 0x8004e4 <xNextTaskUnblockTime>
    1792:	2f c0       	rjmp	.+94     	; 0x17f2 <xTaskIncrementTick+0x11a>
    1794:	8e 01       	movw	r16, r28
    1796:	0e 5f       	subi	r16, 0xFE	; 254
    1798:	1f 4f       	sbci	r17, 0xFF	; 255
    179a:	c8 01       	movw	r24, r16
    179c:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    17a0:	8c 89       	ldd	r24, Y+20	; 0x14
    17a2:	9d 89       	ldd	r25, Y+21	; 0x15
    17a4:	89 2b       	or	r24, r25
    17a6:	21 f0       	breq	.+8      	; 0x17b0 <xTaskIncrementTick+0xd8>
    17a8:	ce 01       	movw	r24, r28
    17aa:	0c 96       	adiw	r24, 0x0c	; 12
    17ac:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    17b0:	2e 89       	ldd	r18, Y+22	; 0x16
    17b2:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    17b6:	82 17       	cp	r24, r18
    17b8:	10 f4       	brcc	.+4      	; 0x17be <xTaskIncrementTick+0xe6>
    17ba:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	c9 01       	movw	r24, r18
    17c2:	88 0f       	add	r24, r24
    17c4:	99 1f       	adc	r25, r25
    17c6:	88 0f       	add	r24, r24
    17c8:	99 1f       	adc	r25, r25
    17ca:	88 0f       	add	r24, r24
    17cc:	99 1f       	adc	r25, r25
    17ce:	82 0f       	add	r24, r18
    17d0:	93 1f       	adc	r25, r19
    17d2:	b8 01       	movw	r22, r16
    17d4:	8f 5d       	subi	r24, 0xDF	; 223
    17d6:	9a 4f       	sbci	r25, 0xFA	; 250
    17d8:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    17dc:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    17e0:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    17e4:	9e 89       	ldd	r25, Y+22	; 0x16
    17e6:	86 89       	ldd	r24, Z+22	; 0x16
    17e8:	98 17       	cp	r25, r24
    17ea:	08 f4       	brcc	.+2      	; 0x17ee <xTaskIncrementTick+0x116>
    17ec:	b2 cf       	rjmp	.-156    	; 0x1752 <xTaskIncrementTick+0x7a>
    17ee:	dc 2c       	mov	r13, r12
    17f0:	b0 cf       	rjmp	.-160    	; 0x1752 <xTaskIncrementTick+0x7a>
    17f2:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    17f6:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    17fa:	86 89       	ldd	r24, Z+22	; 0x16
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	fc 01       	movw	r30, r24
    1800:	ee 0f       	add	r30, r30
    1802:	ff 1f       	adc	r31, r31
    1804:	ee 0f       	add	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	ee 0f       	add	r30, r30
    180a:	ff 1f       	adc	r31, r31
    180c:	8e 0f       	add	r24, r30
    180e:	9f 1f       	adc	r25, r31
    1810:	fc 01       	movw	r30, r24
    1812:	ef 5d       	subi	r30, 0xDF	; 223
    1814:	fa 4f       	sbci	r31, 0xFA	; 250
    1816:	80 81       	ld	r24, Z
    1818:	82 30       	cpi	r24, 0x02	; 2
    181a:	48 f0       	brcs	.+18     	; 0x182e <xTaskIncrementTick+0x156>
    181c:	dd 24       	eor	r13, r13
    181e:	d3 94       	inc	r13
    1820:	06 c0       	rjmp	.+12     	; 0x182e <xTaskIncrementTick+0x156>
    1822:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <uxPendedTicks>
    1826:	8f 5f       	subi	r24, 0xFF	; 255
    1828:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <uxPendedTicks>
    182c:	d1 2c       	mov	r13, r1
    182e:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <xYieldPending>
    1832:	88 23       	and	r24, r24
    1834:	11 f0       	breq	.+4      	; 0x183a <xTaskIncrementTick+0x162>
    1836:	dd 24       	eor	r13, r13
    1838:	d3 94       	inc	r13
    183a:	8d 2d       	mov	r24, r13
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	df 90       	pop	r13
    184a:	cf 90       	pop	r12
    184c:	08 95       	ret

0000184e <xTaskResumeAll>:
    184e:	df 92       	push	r13
    1850:	ef 92       	push	r14
    1852:	ff 92       	push	r15
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	f8 94       	cli
    1860:	0f 92       	push	r0
    1862:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    1866:	81 50       	subi	r24, 0x01	; 1
    1868:	80 93 e1 04 	sts	0x04E1, r24	; 0x8004e1 <uxSchedulerSuspended>
    186c:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    1870:	81 11       	cpse	r24, r1
    1872:	5f c0       	rjmp	.+190    	; 0x1932 <xTaskResumeAll+0xe4>
    1874:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <uxCurrentNumberOfTasks>
    1878:	81 11       	cpse	r24, r1
    187a:	33 c0       	rjmp	.+102    	; 0x18e2 <xTaskResumeAll+0x94>
    187c:	5d c0       	rjmp	.+186    	; 0x1938 <xTaskResumeAll+0xea>
    187e:	d7 01       	movw	r26, r14
    1880:	15 96       	adiw	r26, 0x05	; 5
    1882:	ed 91       	ld	r30, X+
    1884:	fc 91       	ld	r31, X
    1886:	16 97       	sbiw	r26, 0x06	; 6
    1888:	c6 81       	ldd	r28, Z+6	; 0x06
    188a:	d7 81       	ldd	r29, Z+7	; 0x07
    188c:	ce 01       	movw	r24, r28
    188e:	0c 96       	adiw	r24, 0x0c	; 12
    1890:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    1894:	8e 01       	movw	r16, r28
    1896:	0e 5f       	subi	r16, 0xFE	; 254
    1898:	1f 4f       	sbci	r17, 0xFF	; 255
    189a:	c8 01       	movw	r24, r16
    189c:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    18a0:	2e 89       	ldd	r18, Y+22	; 0x16
    18a2:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    18a6:	82 17       	cp	r24, r18
    18a8:	10 f4       	brcc	.+4      	; 0x18ae <xTaskResumeAll+0x60>
    18aa:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    18ae:	30 e0       	ldi	r19, 0x00	; 0
    18b0:	c9 01       	movw	r24, r18
    18b2:	88 0f       	add	r24, r24
    18b4:	99 1f       	adc	r25, r25
    18b6:	88 0f       	add	r24, r24
    18b8:	99 1f       	adc	r25, r25
    18ba:	88 0f       	add	r24, r24
    18bc:	99 1f       	adc	r25, r25
    18be:	82 0f       	add	r24, r18
    18c0:	93 1f       	adc	r25, r19
    18c2:	b8 01       	movw	r22, r16
    18c4:	8f 5d       	subi	r24, 0xDF	; 223
    18c6:	9a 4f       	sbci	r25, 0xFA	; 250
    18c8:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    18cc:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    18d0:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    18d4:	9e 89       	ldd	r25, Y+22	; 0x16
    18d6:	86 89       	ldd	r24, Z+22	; 0x16
    18d8:	98 17       	cp	r25, r24
    18da:	68 f0       	brcs	.+26     	; 0x18f6 <xTaskResumeAll+0xa8>
    18dc:	d0 92 e8 04 	sts	0x04E8, r13	; 0x8004e8 <xYieldPending>
    18e0:	0a c0       	rjmp	.+20     	; 0x18f6 <xTaskResumeAll+0xa8>
    18e2:	c0 e0       	ldi	r28, 0x00	; 0
    18e4:	d0 e0       	ldi	r29, 0x00	; 0
    18e6:	0f 2e       	mov	r0, r31
    18e8:	f2 e0       	ldi	r31, 0x02	; 2
    18ea:	ef 2e       	mov	r14, r31
    18ec:	f5 e0       	ldi	r31, 0x05	; 5
    18ee:	ff 2e       	mov	r15, r31
    18f0:	f0 2d       	mov	r31, r0
    18f2:	dd 24       	eor	r13, r13
    18f4:	d3 94       	inc	r13
    18f6:	f7 01       	movw	r30, r14
    18f8:	80 81       	ld	r24, Z
    18fa:	81 11       	cpse	r24, r1
    18fc:	c0 cf       	rjmp	.-128    	; 0x187e <xTaskResumeAll+0x30>
    18fe:	cd 2b       	or	r28, r29
    1900:	11 f0       	breq	.+4      	; 0x1906 <xTaskResumeAll+0xb8>
    1902:	0e 94 b4 09 	call	0x1368	; 0x1368 <prvResetNextTaskUnblockTime>
    1906:	c0 91 e9 04 	lds	r28, 0x04E9	; 0x8004e9 <uxPendedTicks>
    190a:	cc 23       	and	r28, r28
    190c:	51 f0       	breq	.+20     	; 0x1922 <xTaskResumeAll+0xd4>
    190e:	d1 e0       	ldi	r29, 0x01	; 1
    1910:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <xTaskIncrementTick>
    1914:	81 11       	cpse	r24, r1
    1916:	d0 93 e8 04 	sts	0x04E8, r29	; 0x8004e8 <xYieldPending>
    191a:	c1 50       	subi	r28, 0x01	; 1
    191c:	c9 f7       	brne	.-14     	; 0x1910 <xTaskResumeAll+0xc2>
    191e:	10 92 e9 04 	sts	0x04E9, r1	; 0x8004e9 <uxPendedTicks>
    1922:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <xYieldPending>
    1926:	88 23       	and	r24, r24
    1928:	31 f0       	breq	.+12     	; 0x1936 <xTaskResumeAll+0xe8>
    192a:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    192e:	81 e0       	ldi	r24, 0x01	; 1
    1930:	03 c0       	rjmp	.+6      	; 0x1938 <xTaskResumeAll+0xea>
    1932:	80 e0       	ldi	r24, 0x00	; 0
    1934:	01 c0       	rjmp	.+2      	; 0x1938 <xTaskResumeAll+0xea>
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	ff 90       	pop	r15
    1946:	ef 90       	pop	r14
    1948:	df 90       	pop	r13
    194a:	08 95       	ret

0000194c <vTaskDelay>:
    194c:	cf 93       	push	r28
    194e:	df 93       	push	r29
    1950:	ec 01       	movw	r28, r24
    1952:	89 2b       	or	r24, r25
    1954:	51 f0       	breq	.+20     	; 0x196a <vTaskDelay+0x1e>
    1956:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
    195a:	60 e0       	ldi	r22, 0x00	; 0
    195c:	ce 01       	movw	r24, r28
    195e:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvAddCurrentTaskToDelayedList>
    1962:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    1966:	81 11       	cpse	r24, r1
    1968:	02 c0       	rjmp	.+4      	; 0x196e <vTaskDelay+0x22>
    196a:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	08 95       	ret

00001974 <prvIdleTask>:
    1974:	09 ef       	ldi	r16, 0xF9	; 249
    1976:	14 e0       	ldi	r17, 0x04	; 4
    1978:	0f 2e       	mov	r0, r31
    197a:	f1 e2       	ldi	r31, 0x21	; 33
    197c:	ef 2e       	mov	r14, r31
    197e:	f5 e0       	ldi	r31, 0x05	; 5
    1980:	ff 2e       	mov	r15, r31
    1982:	f0 2d       	mov	r31, r0
    1984:	29 c0       	rjmp	.+82     	; 0x19d8 <prvIdleTask+0x64>
    1986:	0e 94 66 0b 	call	0x16cc	; 0x16cc <vTaskSuspendAll>
    198a:	d8 01       	movw	r26, r16
    198c:	cc 91       	ld	r28, X
    198e:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
    1992:	cc 23       	and	r28, r28
    1994:	09 f1       	breq	.+66     	; 0x19d8 <prvIdleTask+0x64>
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
    199c:	d8 01       	movw	r26, r16
    199e:	15 96       	adiw	r26, 0x05	; 5
    19a0:	ed 91       	ld	r30, X+
    19a2:	fc 91       	ld	r31, X
    19a4:	16 97       	sbiw	r26, 0x06	; 6
    19a6:	c6 81       	ldd	r28, Z+6	; 0x06
    19a8:	d7 81       	ldd	r29, Z+7	; 0x07
    19aa:	ce 01       	movw	r24, r28
    19ac:	02 96       	adiw	r24, 0x02	; 2
    19ae:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    19b2:	80 91 ee 04 	lds	r24, 0x04EE	; 0x8004ee <uxCurrentNumberOfTasks>
    19b6:	81 50       	subi	r24, 0x01	; 1
    19b8:	80 93 ee 04 	sts	0x04EE, r24	; 0x8004ee <uxCurrentNumberOfTasks>
    19bc:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxDeletedTasksWaitingCleanUp>
    19c0:	81 50       	subi	r24, 0x01	; 1
    19c2:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxDeletedTasksWaitingCleanUp>
    19c6:	0f 90       	pop	r0
    19c8:	0f be       	out	0x3f, r0	; 63
    19ca:	8f 89       	ldd	r24, Y+23	; 0x17
    19cc:	98 8d       	ldd	r25, Y+24	; 0x18
    19ce:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    19d2:	ce 01       	movw	r24, r28
    19d4:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    19d8:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxDeletedTasksWaitingCleanUp>
    19dc:	81 11       	cpse	r24, r1
    19de:	d3 cf       	rjmp	.-90     	; 0x1986 <prvIdleTask+0x12>
    19e0:	f7 01       	movw	r30, r14
    19e2:	80 81       	ld	r24, Z
    19e4:	82 30       	cpi	r24, 0x02	; 2
    19e6:	c0 f3       	brcs	.-16     	; 0x19d8 <prvIdleTask+0x64>
    19e8:	0e 94 5d 06 	call	0xcba	; 0xcba <vPortYield>
    19ec:	f5 cf       	rjmp	.-22     	; 0x19d8 <prvIdleTask+0x64>

000019ee <vTaskSwitchContext>:
    19ee:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    19f2:	88 23       	and	r24, r24
    19f4:	21 f0       	breq	.+8      	; 0x19fe <vTaskSwitchContext+0x10>
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <xYieldPending>
    19fc:	08 95       	ret
    19fe:	10 92 e8 04 	sts	0x04E8, r1	; 0x8004e8 <xYieldPending>
    1a02:	20 91 eb 04 	lds	r18, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1a06:	82 2f       	mov	r24, r18
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	fc 01       	movw	r30, r24
    1a0c:	ee 0f       	add	r30, r30
    1a0e:	ff 1f       	adc	r31, r31
    1a10:	ee 0f       	add	r30, r30
    1a12:	ff 1f       	adc	r31, r31
    1a14:	ee 0f       	add	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	e8 0f       	add	r30, r24
    1a1a:	f9 1f       	adc	r31, r25
    1a1c:	ef 5d       	subi	r30, 0xDF	; 223
    1a1e:	fa 4f       	sbci	r31, 0xFA	; 250
    1a20:	30 81       	ld	r19, Z
    1a22:	31 11       	cpse	r19, r1
    1a24:	11 c0       	rjmp	.+34     	; 0x1a48 <vTaskSwitchContext+0x5a>
    1a26:	21 50       	subi	r18, 0x01	; 1
    1a28:	82 2f       	mov	r24, r18
    1a2a:	90 e0       	ldi	r25, 0x00	; 0
    1a2c:	fc 01       	movw	r30, r24
    1a2e:	ee 0f       	add	r30, r30
    1a30:	ff 1f       	adc	r31, r31
    1a32:	ee 0f       	add	r30, r30
    1a34:	ff 1f       	adc	r31, r31
    1a36:	ee 0f       	add	r30, r30
    1a38:	ff 1f       	adc	r31, r31
    1a3a:	e8 0f       	add	r30, r24
    1a3c:	f9 1f       	adc	r31, r25
    1a3e:	ef 5d       	subi	r30, 0xDF	; 223
    1a40:	fa 4f       	sbci	r31, 0xFA	; 250
    1a42:	30 81       	ld	r19, Z
    1a44:	33 23       	and	r19, r19
    1a46:	79 f3       	breq	.-34     	; 0x1a26 <vTaskSwitchContext+0x38>
    1a48:	ac 01       	movw	r20, r24
    1a4a:	44 0f       	add	r20, r20
    1a4c:	55 1f       	adc	r21, r21
    1a4e:	44 0f       	add	r20, r20
    1a50:	55 1f       	adc	r21, r21
    1a52:	44 0f       	add	r20, r20
    1a54:	55 1f       	adc	r21, r21
    1a56:	48 0f       	add	r20, r24
    1a58:	59 1f       	adc	r21, r25
    1a5a:	da 01       	movw	r26, r20
    1a5c:	af 5d       	subi	r26, 0xDF	; 223
    1a5e:	ba 4f       	sbci	r27, 0xFA	; 250
    1a60:	11 96       	adiw	r26, 0x01	; 1
    1a62:	ed 91       	ld	r30, X+
    1a64:	fc 91       	ld	r31, X
    1a66:	12 97       	sbiw	r26, 0x02	; 2
    1a68:	02 80       	ldd	r0, Z+2	; 0x02
    1a6a:	f3 81       	ldd	r31, Z+3	; 0x03
    1a6c:	e0 2d       	mov	r30, r0
    1a6e:	12 96       	adiw	r26, 0x02	; 2
    1a70:	fc 93       	st	X, r31
    1a72:	ee 93       	st	-X, r30
    1a74:	11 97       	sbiw	r26, 0x01	; 1
    1a76:	4c 5d       	subi	r20, 0xDC	; 220
    1a78:	5a 4f       	sbci	r21, 0xFA	; 250
    1a7a:	e4 17       	cp	r30, r20
    1a7c:	f5 07       	cpc	r31, r21
    1a7e:	29 f4       	brne	.+10     	; 0x1a8a <vTaskSwitchContext+0x9c>
    1a80:	42 81       	ldd	r20, Z+2	; 0x02
    1a82:	53 81       	ldd	r21, Z+3	; 0x03
    1a84:	fd 01       	movw	r30, r26
    1a86:	52 83       	std	Z+2, r21	; 0x02
    1a88:	41 83       	std	Z+1, r20	; 0x01
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	ee 0f       	add	r30, r30
    1a8e:	ff 1f       	adc	r31, r31
    1a90:	ee 0f       	add	r30, r30
    1a92:	ff 1f       	adc	r31, r31
    1a94:	ee 0f       	add	r30, r30
    1a96:	ff 1f       	adc	r31, r31
    1a98:	8e 0f       	add	r24, r30
    1a9a:	9f 1f       	adc	r25, r31
    1a9c:	fc 01       	movw	r30, r24
    1a9e:	ef 5d       	subi	r30, 0xDF	; 223
    1aa0:	fa 4f       	sbci	r31, 0xFA	; 250
    1aa2:	01 80       	ldd	r0, Z+1	; 0x01
    1aa4:	f2 81       	ldd	r31, Z+2	; 0x02
    1aa6:	e0 2d       	mov	r30, r0
    1aa8:	86 81       	ldd	r24, Z+6	; 0x06
    1aaa:	97 81       	ldd	r25, Z+7	; 0x07
    1aac:	90 93 4f 05 	sts	0x054F, r25	; 0x80054f <pxCurrentTCB+0x1>
    1ab0:	80 93 4e 05 	sts	0x054E, r24	; 0x80054e <pxCurrentTCB>
    1ab4:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    1ab8:	08 95       	ret

00001aba <vTaskPlaceOnEventList>:
    1aba:	cf 93       	push	r28
    1abc:	df 93       	push	r29
    1abe:	eb 01       	movw	r28, r22
    1ac0:	20 91 4e 05 	lds	r18, 0x054E	; 0x80054e <pxCurrentTCB>
    1ac4:	30 91 4f 05 	lds	r19, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1ac8:	b9 01       	movw	r22, r18
    1aca:	64 5f       	subi	r22, 0xF4	; 244
    1acc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ace:	0e 94 35 03 	call	0x66a	; 0x66a <vListInsert>
    1ad2:	61 e0       	ldi	r22, 0x01	; 1
    1ad4:	ce 01       	movw	r24, r28
    1ad6:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvAddCurrentTaskToDelayedList>
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	08 95       	ret

00001ae0 <xTaskRemoveFromEventList>:
    1ae0:	0f 93       	push	r16
    1ae2:	1f 93       	push	r17
    1ae4:	cf 93       	push	r28
    1ae6:	df 93       	push	r29
    1ae8:	dc 01       	movw	r26, r24
    1aea:	15 96       	adiw	r26, 0x05	; 5
    1aec:	ed 91       	ld	r30, X+
    1aee:	fc 91       	ld	r31, X
    1af0:	16 97       	sbiw	r26, 0x06	; 6
    1af2:	c6 81       	ldd	r28, Z+6	; 0x06
    1af4:	d7 81       	ldd	r29, Z+7	; 0x07
    1af6:	8e 01       	movw	r16, r28
    1af8:	04 5f       	subi	r16, 0xF4	; 244
    1afa:	1f 4f       	sbci	r17, 0xFF	; 255
    1afc:	c8 01       	movw	r24, r16
    1afe:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    1b02:	80 91 e1 04 	lds	r24, 0x04E1	; 0x8004e1 <uxSchedulerSuspended>
    1b06:	81 11       	cpse	r24, r1
    1b08:	1c c0       	rjmp	.+56     	; 0x1b42 <xTaskRemoveFromEventList+0x62>
    1b0a:	0a 50       	subi	r16, 0x0A	; 10
    1b0c:	11 09       	sbc	r17, r1
    1b0e:	c8 01       	movw	r24, r16
    1b10:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    1b14:	2e 89       	ldd	r18, Y+22	; 0x16
    1b16:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1b1a:	82 17       	cp	r24, r18
    1b1c:	10 f4       	brcc	.+4      	; 0x1b22 <xTaskRemoveFromEventList+0x42>
    1b1e:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    1b22:	30 e0       	ldi	r19, 0x00	; 0
    1b24:	c9 01       	movw	r24, r18
    1b26:	88 0f       	add	r24, r24
    1b28:	99 1f       	adc	r25, r25
    1b2a:	88 0f       	add	r24, r24
    1b2c:	99 1f       	adc	r25, r25
    1b2e:	88 0f       	add	r24, r24
    1b30:	99 1f       	adc	r25, r25
    1b32:	82 0f       	add	r24, r18
    1b34:	93 1f       	adc	r25, r19
    1b36:	b8 01       	movw	r22, r16
    1b38:	8f 5d       	subi	r24, 0xDF	; 223
    1b3a:	9a 4f       	sbci	r25, 0xFA	; 250
    1b3c:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    1b40:	05 c0       	rjmp	.+10     	; 0x1b4c <xTaskRemoveFromEventList+0x6c>
    1b42:	b8 01       	movw	r22, r16
    1b44:	82 e0       	ldi	r24, 0x02	; 2
    1b46:	95 e0       	ldi	r25, 0x05	; 5
    1b48:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    1b4c:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    1b50:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1b54:	9e 89       	ldd	r25, Y+22	; 0x16
    1b56:	86 89       	ldd	r24, Z+22	; 0x16
    1b58:	89 17       	cp	r24, r25
    1b5a:	20 f4       	brcc	.+8      	; 0x1b64 <xTaskRemoveFromEventList+0x84>
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <xYieldPending>
    1b62:	01 c0       	rjmp	.+2      	; 0x1b66 <xTaskRemoveFromEventList+0x86>
    1b64:	80 e0       	ldi	r24, 0x00	; 0
    1b66:	df 91       	pop	r29
    1b68:	cf 91       	pop	r28
    1b6a:	1f 91       	pop	r17
    1b6c:	0f 91       	pop	r16
    1b6e:	08 95       	ret

00001b70 <vTaskSetTimeOutState>:
    1b70:	20 91 e7 04 	lds	r18, 0x04E7	; 0x8004e7 <xNumOfOverflows>
    1b74:	fc 01       	movw	r30, r24
    1b76:	20 83       	st	Z, r18
    1b78:	20 91 ec 04 	lds	r18, 0x04EC	; 0x8004ec <xTickCount>
    1b7c:	30 91 ed 04 	lds	r19, 0x04ED	; 0x8004ed <xTickCount+0x1>
    1b80:	32 83       	std	Z+2, r19	; 0x02
    1b82:	21 83       	std	Z+1, r18	; 0x01
    1b84:	08 95       	ret

00001b86 <xTaskCheckForTimeOut>:
    1b86:	0f b6       	in	r0, 0x3f	; 63
    1b88:	f8 94       	cli
    1b8a:	0f 92       	push	r0
    1b8c:	40 91 ec 04 	lds	r20, 0x04EC	; 0x8004ec <xTickCount>
    1b90:	50 91 ed 04 	lds	r21, 0x04ED	; 0x8004ed <xTickCount+0x1>
    1b94:	db 01       	movw	r26, r22
    1b96:	2d 91       	ld	r18, X+
    1b98:	3c 91       	ld	r19, X
    1b9a:	2f 3f       	cpi	r18, 0xFF	; 255
    1b9c:	bf ef       	ldi	r27, 0xFF	; 255
    1b9e:	3b 07       	cpc	r19, r27
    1ba0:	19 f1       	breq	.+70     	; 0x1be8 <xTaskCheckForTimeOut+0x62>
    1ba2:	e0 91 e7 04 	lds	r30, 0x04E7	; 0x8004e7 <xNumOfOverflows>
    1ba6:	dc 01       	movw	r26, r24
    1ba8:	fc 91       	ld	r31, X
    1baa:	fe 17       	cp	r31, r30
    1bac:	39 f0       	breq	.+14     	; 0x1bbc <xTaskCheckForTimeOut+0x36>
    1bae:	11 96       	adiw	r26, 0x01	; 1
    1bb0:	ed 91       	ld	r30, X+
    1bb2:	fc 91       	ld	r31, X
    1bb4:	12 97       	sbiw	r26, 0x02	; 2
    1bb6:	4e 17       	cp	r20, r30
    1bb8:	5f 07       	cpc	r21, r31
    1bba:	c0 f4       	brcc	.+48     	; 0x1bec <xTaskCheckForTimeOut+0x66>
    1bbc:	dc 01       	movw	r26, r24
    1bbe:	11 96       	adiw	r26, 0x01	; 1
    1bc0:	ed 91       	ld	r30, X+
    1bc2:	fc 91       	ld	r31, X
    1bc4:	12 97       	sbiw	r26, 0x02	; 2
    1bc6:	da 01       	movw	r26, r20
    1bc8:	ae 1b       	sub	r26, r30
    1bca:	bf 0b       	sbc	r27, r31
    1bcc:	a2 17       	cp	r26, r18
    1bce:	b3 07       	cpc	r27, r19
    1bd0:	78 f4       	brcc	.+30     	; 0x1bf0 <xTaskCheckForTimeOut+0x6a>
    1bd2:	db 01       	movw	r26, r22
    1bd4:	e4 1b       	sub	r30, r20
    1bd6:	f5 0b       	sbc	r31, r21
    1bd8:	2e 0f       	add	r18, r30
    1bda:	3f 1f       	adc	r19, r31
    1bdc:	2d 93       	st	X+, r18
    1bde:	3c 93       	st	X, r19
    1be0:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vTaskSetTimeOutState>
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	05 c0       	rjmp	.+10     	; 0x1bf2 <xTaskCheckForTimeOut+0x6c>
    1be8:	80 e0       	ldi	r24, 0x00	; 0
    1bea:	03 c0       	rjmp	.+6      	; 0x1bf2 <xTaskCheckForTimeOut+0x6c>
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	01 c0       	rjmp	.+2      	; 0x1bf2 <xTaskCheckForTimeOut+0x6c>
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	0f 90       	pop	r0
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	08 95       	ret

00001bf8 <vTaskMissedYield>:
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <xYieldPending>
    1bfe:	08 95       	ret

00001c00 <vTaskPriorityInherit>:
    1c00:	0f 93       	push	r16
    1c02:	1f 93       	push	r17
    1c04:	cf 93       	push	r28
    1c06:	df 93       	push	r29
    1c08:	fc 01       	movw	r30, r24
    1c0a:	89 2b       	or	r24, r25
    1c0c:	09 f4       	brne	.+2      	; 0x1c10 <vTaskPriorityInherit+0x10>
    1c0e:	55 c0       	rjmp	.+170    	; 0x1cba <vTaskPriorityInherit+0xba>
    1c10:	26 89       	ldd	r18, Z+22	; 0x16
    1c12:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
    1c16:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1c1a:	56 96       	adiw	r26, 0x16	; 22
    1c1c:	8c 91       	ld	r24, X
    1c1e:	28 17       	cp	r18, r24
    1c20:	08 f0       	brcs	.+2      	; 0x1c24 <vTaskPriorityInherit+0x24>
    1c22:	4b c0       	rjmp	.+150    	; 0x1cba <vTaskPriorityInherit+0xba>
    1c24:	84 85       	ldd	r24, Z+12	; 0x0c
    1c26:	95 85       	ldd	r25, Z+13	; 0x0d
    1c28:	99 23       	and	r25, r25
    1c2a:	64 f0       	brlt	.+24     	; 0x1c44 <vTaskPriorityInherit+0x44>
    1c2c:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
    1c30:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1c34:	56 96       	adiw	r26, 0x16	; 22
    1c36:	3c 91       	ld	r19, X
    1c38:	85 e0       	ldi	r24, 0x05	; 5
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	83 1b       	sub	r24, r19
    1c3e:	91 09       	sbc	r25, r1
    1c40:	95 87       	std	Z+13, r25	; 0x0d
    1c42:	84 87       	std	Z+12, r24	; 0x0c
    1c44:	30 e0       	ldi	r19, 0x00	; 0
    1c46:	c9 01       	movw	r24, r18
    1c48:	88 0f       	add	r24, r24
    1c4a:	99 1f       	adc	r25, r25
    1c4c:	88 0f       	add	r24, r24
    1c4e:	99 1f       	adc	r25, r25
    1c50:	88 0f       	add	r24, r24
    1c52:	99 1f       	adc	r25, r25
    1c54:	28 0f       	add	r18, r24
    1c56:	39 1f       	adc	r19, r25
    1c58:	2f 5d       	subi	r18, 0xDF	; 223
    1c5a:	3a 4f       	sbci	r19, 0xFA	; 250
    1c5c:	82 85       	ldd	r24, Z+10	; 0x0a
    1c5e:	93 85       	ldd	r25, Z+11	; 0x0b
    1c60:	82 17       	cp	r24, r18
    1c62:	93 07       	cpc	r25, r19
    1c64:	19 f5       	brne	.+70     	; 0x1cac <vTaskPriorityInherit+0xac>
    1c66:	8f 01       	movw	r16, r30
    1c68:	ef 01       	movw	r28, r30
    1c6a:	22 96       	adiw	r28, 0x02	; 2
    1c6c:	ce 01       	movw	r24, r28
    1c6e:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    1c72:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    1c76:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1c7a:	26 89       	ldd	r18, Z+22	; 0x16
    1c7c:	f8 01       	movw	r30, r16
    1c7e:	26 8b       	std	Z+22, r18	; 0x16
    1c80:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1c84:	82 17       	cp	r24, r18
    1c86:	10 f4       	brcc	.+4      	; 0x1c8c <vTaskPriorityInherit+0x8c>
    1c88:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    1c8c:	30 e0       	ldi	r19, 0x00	; 0
    1c8e:	c9 01       	movw	r24, r18
    1c90:	88 0f       	add	r24, r24
    1c92:	99 1f       	adc	r25, r25
    1c94:	88 0f       	add	r24, r24
    1c96:	99 1f       	adc	r25, r25
    1c98:	88 0f       	add	r24, r24
    1c9a:	99 1f       	adc	r25, r25
    1c9c:	82 0f       	add	r24, r18
    1c9e:	93 1f       	adc	r25, r19
    1ca0:	be 01       	movw	r22, r28
    1ca2:	8f 5d       	subi	r24, 0xDF	; 223
    1ca4:	9a 4f       	sbci	r25, 0xFA	; 250
    1ca6:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    1caa:	07 c0       	rjmp	.+14     	; 0x1cba <vTaskPriorityInherit+0xba>
    1cac:	a0 91 4e 05 	lds	r26, 0x054E	; 0x80054e <pxCurrentTCB>
    1cb0:	b0 91 4f 05 	lds	r27, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1cb4:	56 96       	adiw	r26, 0x16	; 22
    1cb6:	8c 91       	ld	r24, X
    1cb8:	86 8b       	std	Z+22, r24	; 0x16
    1cba:	df 91       	pop	r29
    1cbc:	cf 91       	pop	r28
    1cbe:	1f 91       	pop	r17
    1cc0:	0f 91       	pop	r16
    1cc2:	08 95       	ret

00001cc4 <xTaskPriorityDisinherit>:
    1cc4:	0f 93       	push	r16
    1cc6:	1f 93       	push	r17
    1cc8:	cf 93       	push	r28
    1cca:	df 93       	push	r29
    1ccc:	fc 01       	movw	r30, r24
    1cce:	89 2b       	or	r24, r25
    1cd0:	79 f1       	breq	.+94     	; 0x1d30 <xTaskPriorityDisinherit+0x6c>
    1cd2:	84 a1       	ldd	r24, Z+36	; 0x24
    1cd4:	81 50       	subi	r24, 0x01	; 1
    1cd6:	84 a3       	std	Z+36, r24	; 0x24
    1cd8:	26 89       	ldd	r18, Z+22	; 0x16
    1cda:	93 a1       	ldd	r25, Z+35	; 0x23
    1cdc:	29 17       	cp	r18, r25
    1cde:	51 f1       	breq	.+84     	; 0x1d34 <xTaskPriorityDisinherit+0x70>
    1ce0:	81 11       	cpse	r24, r1
    1ce2:	2a c0       	rjmp	.+84     	; 0x1d38 <xTaskPriorityDisinherit+0x74>
    1ce4:	ef 01       	movw	r28, r30
    1ce6:	8f 01       	movw	r16, r30
    1ce8:	0e 5f       	subi	r16, 0xFE	; 254
    1cea:	1f 4f       	sbci	r17, 0xFF	; 255
    1cec:	c8 01       	movw	r24, r16
    1cee:	0e 94 66 03 	call	0x6cc	; 0x6cc <uxListRemove>
    1cf2:	2b a1       	ldd	r18, Y+35	; 0x23
    1cf4:	2e 8b       	std	Y+22, r18	; 0x16
    1cf6:	45 e0       	ldi	r20, 0x05	; 5
    1cf8:	50 e0       	ldi	r21, 0x00	; 0
    1cfa:	42 1b       	sub	r20, r18
    1cfc:	51 09       	sbc	r21, r1
    1cfe:	5d 87       	std	Y+13, r21	; 0x0d
    1d00:	4c 87       	std	Y+12, r20	; 0x0c
    1d02:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <uxTopReadyPriority>
    1d06:	82 17       	cp	r24, r18
    1d08:	10 f4       	brcc	.+4      	; 0x1d0e <xTaskPriorityDisinherit+0x4a>
    1d0a:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <uxTopReadyPriority>
    1d0e:	30 e0       	ldi	r19, 0x00	; 0
    1d10:	c9 01       	movw	r24, r18
    1d12:	88 0f       	add	r24, r24
    1d14:	99 1f       	adc	r25, r25
    1d16:	88 0f       	add	r24, r24
    1d18:	99 1f       	adc	r25, r25
    1d1a:	88 0f       	add	r24, r24
    1d1c:	99 1f       	adc	r25, r25
    1d1e:	82 0f       	add	r24, r18
    1d20:	93 1f       	adc	r25, r19
    1d22:	b8 01       	movw	r22, r16
    1d24:	8f 5d       	subi	r24, 0xDF	; 223
    1d26:	9a 4f       	sbci	r25, 0xFA	; 250
    1d28:	0e 94 14 03 	call	0x628	; 0x628 <vListInsertEnd>
    1d2c:	81 e0       	ldi	r24, 0x01	; 1
    1d2e:	05 c0       	rjmp	.+10     	; 0x1d3a <xTaskPriorityDisinherit+0x76>
    1d30:	80 e0       	ldi	r24, 0x00	; 0
    1d32:	03 c0       	rjmp	.+6      	; 0x1d3a <xTaskPriorityDisinherit+0x76>
    1d34:	80 e0       	ldi	r24, 0x00	; 0
    1d36:	01 c0       	rjmp	.+2      	; 0x1d3a <xTaskPriorityDisinherit+0x76>
    1d38:	80 e0       	ldi	r24, 0x00	; 0
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	08 95       	ret

00001d44 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1d44:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <pxCurrentTCB>
    1d48:	90 91 4f 05 	lds	r25, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1d4c:	89 2b       	or	r24, r25
    1d4e:	39 f0       	breq	.+14     	; 0x1d5e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1d50:	e0 91 4e 05 	lds	r30, 0x054E	; 0x80054e <pxCurrentTCB>
    1d54:	f0 91 4f 05 	lds	r31, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
    1d58:	84 a1       	ldd	r24, Z+36	; 0x24
    1d5a:	8f 5f       	subi	r24, 0xFF	; 255
    1d5c:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    1d5e:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <pxCurrentTCB>
    1d62:	90 91 4f 05 	lds	r25, 0x054F	; 0x80054f <pxCurrentTCB+0x1>
	}
    1d66:	08 95       	ret

00001d68 <memcpy>:
    1d68:	fb 01       	movw	r30, r22
    1d6a:	dc 01       	movw	r26, r24
    1d6c:	02 c0       	rjmp	.+4      	; 0x1d72 <memcpy+0xa>
    1d6e:	01 90       	ld	r0, Z+
    1d70:	0d 92       	st	X+, r0
    1d72:	41 50       	subi	r20, 0x01	; 1
    1d74:	50 40       	sbci	r21, 0x00	; 0
    1d76:	d8 f7       	brcc	.-10     	; 0x1d6e <memcpy+0x6>
    1d78:	08 95       	ret

00001d7a <strcmp>:
    1d7a:	fb 01       	movw	r30, r22
    1d7c:	dc 01       	movw	r26, r24
    1d7e:	8d 91       	ld	r24, X+
    1d80:	01 90       	ld	r0, Z+
    1d82:	80 19       	sub	r24, r0
    1d84:	01 10       	cpse	r0, r1
    1d86:	d9 f3       	breq	.-10     	; 0x1d7e <strcmp+0x4>
    1d88:	99 0b       	sbc	r25, r25
    1d8a:	08 95       	ret

00001d8c <_exit>:
    1d8c:	f8 94       	cli

00001d8e <__stop_program>:
    1d8e:	ff cf       	rjmp	.-2      	; 0x1d8e <__stop_program>
